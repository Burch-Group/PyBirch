{% extends "base.html" %}
{% from "macros.html" import detail_action_buttons %}

{% block title %}{{ scan.scan_name or 'Scan' }} - PyBirch Database{% endblock %}

{% block extra_head %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<style>
    .chart-wrapper {
        margin-bottom: 2rem;
        background: var(--card-bg);
        border-radius: 8px;
        padding: 1.5rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .chart-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
    }
    .chart-header h3 {
        margin: 0;
        color: var(--text-primary);
    }
    .chart-meta {
        display: flex;
        gap: 1rem;
        font-size: 0.9rem;
        color: var(--text-secondary);
    }
    .chart-container {
        position: relative;
        height: 350px;
    }
    .axis-selector {
        display: flex;
        gap: 1rem;
        margin-bottom: 1rem;
        align-items: center;
    }
    .axis-selector label {
        font-weight: 500;
    }
    .axis-selector select {
        padding: 0.375rem 0.75rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: var(--input-bg);
        color: var(--text-primary);
    }
    .data-summary {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 1rem;
        margin-bottom: 1rem;
        padding: 1rem;
        background: var(--bg-secondary);
        border-radius: 4px;
    }
    .data-summary-item {
        text-align: center;
    }
    .data-summary-item .label {
        font-size: 0.8rem;
        color: var(--text-secondary);
    }
    .data-summary-item .value {
        font-size: 1.2rem;
        font-weight: 600;
        color: var(--text-primary);
    }
    .table-scroll {
        max-height: 400px;
        overflow-y: auto;
    }
    .measurement-tabs {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1.5rem;
        flex-wrap: wrap;
    }
    .measurement-tab {
        padding: 0.5rem 1rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: var(--card-bg);
        cursor: pointer;
        transition: all 0.2s;
    }
    .measurement-tab:hover {
        background: var(--bg-secondary);
    }
    .measurement-tab.active {
        background: var(--primary-color);
        color: white;
        border-color: var(--primary-color);
    }
    .measurement-section {
        display: none;
    }
    .measurement-section.active {
        display: block;
    }
    .no-data-message {
        text-align: center;
        padding: 2rem;
        color: var(--text-secondary);
    }
    /* Visualization Controls */
    .viz-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        margin-bottom: 1rem;
        padding: 1rem;
        background: var(--bg-secondary);
        border-radius: 6px;
        align-items: center;
    }
    .viz-control-group {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    .viz-control-group label {
        font-weight: 500;
        font-size: 0.9rem;
        white-space: nowrap;
    }
    .viz-control-group select {
        padding: 0.375rem 0.75rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: var(--input-bg);
        color: var(--text-primary);
        min-width: 120px;
    }
    /* Visualization action buttons - icon style */
    .viz-action-buttons {
        display: flex;
        gap: 0.5rem;
        margin-left: auto;
        align-items: center;
    }
    .viz-action-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 36px;
        height: 36px;
        padding: 0;
        border: 1px solid var(--border-color, #ddd);
        border-radius: 4px;
        background-color: var(--bg-primary, white);
        color: var(--text-secondary, #666);
        cursor: pointer;
        transition: all 0.15s;
        text-decoration: none;
    }
    .viz-action-btn:hover {
        background-color: var(--bg-tertiary, #f0f0f0);
        color: var(--text-primary, #333);
        text-decoration: none;
    }
    .viz-action-btn svg {
        width: 18px;
        height: 18px;
    }
    .viz-action-btn.btn-download:hover {
        color: #28a745;
        border-color: #28a745;
    }
    .viz-action-btn.btn-save-to-sample:hover {
        color: #0275d8;
        border-color: #0275d8;
    }
    .viz-action-btn:disabled {
        opacity: 0.7;
        cursor: wait;
    }
    /* Heatmap container */
    .heatmap-container {
        position: relative;
        height: 400px;
        width: 100%;
    }
    /* Color scale preview */
    .colorscale-preview {
        height: 8px;
        width: 100%;
        margin-top: 4px;
        border-radius: 2px;
        background: linear-gradient(to right, #440154, #482878, #3e4989, #31688e, #26828e, #1f9e89, #35b779, #6ece58, #b5de2b, #fde725);
    }
    .colorscale-preview.plasma {
        background: linear-gradient(to right, #0d0887, #5302a3, #8b0aa5, #b83289, #db5c68, #f48849, #febd2a, #f0f921);
    }
    .colorscale-preview.inferno {
        background: linear-gradient(to right, #000004, #1b0c41, #4a0c6b, #781c6d, #a52c60, #cf4446, #ed6925, #fb9b06, #f7d13d, #fcffa4);
    }
    .colorscale-preview.cividis {
        background: linear-gradient(to right, #00224e, #123570, #3b496c, #575d6d, #707173, #8a8678, #a59c74, #c3b369, #e1cc55, #fee838);
    }
    /* Hidden by default for chart type switching */
    .chart-view { display: block; }
    .heatmap-view { display: none; }
    .show-heatmap .chart-view { display: none; }
    .show-heatmap .heatmap-view { display: block; }
    
    /* Save hint (shown when no sample linked) */
    .save-hint {
        color: var(--text-tertiary);
        font-size: 0.75rem;
        font-style: italic;
        margin-left: 0.5rem;
    }
    /* Dimension Reduction Panel */
    .dim-reduction-panel {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 1rem;
        margin-bottom: 1rem;
    }
    .dim-reduction-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.75rem;
    }
    .dim-reduction-panel h4 {
        margin: 0;
        font-size: 0.95rem;
        color: var(--text-primary);
    }
    .dim-reduction-info {
        font-weight: normal;
        font-size: 0.8rem;
        color: var(--text-secondary);
    }
    .reductions-container {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }
    .reductions-container:empty + .add-reduction-btn {
        margin-top: 0;
    }
    .reduction-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
        padding: 0.75rem;
        background: var(--card-bg);
        border: 1px solid var(--border-color);
        border-radius: 4px;
    }
    .reduction-row .viz-control-group {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    .reduction-method-group {
        display: flex;
        gap: 0.35rem;
        flex-wrap: wrap;
    }
    .reduction-method-btn {
        padding: 0.3rem 0.6rem;
        border: none;
        border-radius: 4px;
        background: var(--color-bg-secondary, #f8f9fa);
        color: var(--color-text-primary, #212529);
        cursor: pointer;
        font-size: 0.8rem;
        transition: all 0.2s;
    }
    .reduction-method-btn:hover {
        background: var(--color-bg-tertiary, #e9ecef);
    }
    .reduction-method-btn.active {
        background: var(--color-primary, #0078d4);
        color: #ffffff;
    }
    .slice-slider-container {
        display: none;
        align-items: center;
        gap: 0.5rem;
        flex: 1;
        min-width: 150px;
    }
    .slice-slider-container.active {
        display: flex;
    }
    .slice-slider-container input[type="range"] {
        flex: 1;
        min-width: 80px;
    }
    .slice-value {
        font-weight: 600;
        min-width: 60px;
        text-align: right;
        font-size: 0.85rem;
    }
    .dim-info {
        font-size: 0.8rem;
        color: var(--text-secondary);
    }
    .remove-reduction-btn {
        padding: 0.25rem 0.5rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: transparent;
        color: var(--text-secondary);
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s;
        margin-left: auto;
    }
    .remove-reduction-btn:hover {
        background: #dc3545;
        color: white;
        border-color: #dc3545;
    }
    .add-reduction-btn {
        padding: 0.5rem 1rem;
        border: 1px dashed var(--border-color);
        border-radius: 4px;
        background: transparent;
        color: var(--text-secondary);
        cursor: pointer;
        font-size: 0.85rem;
        transition: all 0.2s;
        margin-top: 0.75rem;
        width: 100%;
    }
    .add-reduction-btn:hover:not(.disabled) {
        background: var(--card-bg);
        border-color: var(--primary-color);
        color: var(--primary-color);
    }
    .add-reduction-btn.disabled {
        opacity: 0.5;
        cursor: not-allowed;
        border-style: solid;
    }
    /* Legacy styles for backwards compatibility */
    .dim-reduction-row {
        font-size: 0.8rem;
        color: var(--text-secondary);
        font-style: italic;
    }
    /* Section header with inline button */
    .section-header-inline {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 1rem;
    }
    .section-header-inline h2 {
        margin: 0;
    }
    .section-header-inline .btn svg {
        margin-right: 0.25rem;
    }
    /* Edit Links Modal */
    .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        align-items: center;
        justify-content: center;
    }
    .modal-overlay.active {
        display: flex;
    }
    .modal-content {
        background: var(--card-bg, #fff);
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        width: 100%;
        max-width: 500px;
        max-height: 90vh;
        overflow-y: auto;
    }
    .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1rem 1.5rem;
        border-bottom: 1px solid var(--border-color, #e5e7eb);
    }
    .modal-header h3 {
        margin: 0;
        font-size: 1.25rem;
    }
    .modal-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: var(--text-secondary, #666);
        padding: 0;
        line-height: 1;
    }
    .modal-close:hover {
        color: var(--text-primary, #333);
    }
    .modal-body {
        padding: 1.5rem;
    }
    .modal-body .form-group {
        margin-bottom: 1.25rem;
    }
    .modal-body .form-group:last-child {
        margin-bottom: 0;
    }
    .modal-body label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 500;
    }
    .modal-body select {
        width: 100%;
        padding: 0.5rem 0.75rem;
        border: 1px solid var(--border-color, #e5e7eb);
        border-radius: 4px;
        background: var(--input-bg, #fff);
        color: var(--text-primary, #333);
        font-size: 1rem;
    }
    .modal-body .form-text {
        display: block;
        margin-top: 0.25rem;
        font-size: 0.85rem;
        color: var(--text-secondary, #666);
    }
    .modal-footer {
        display: flex;
        justify-content: flex-end;
        gap: 0.75rem;
        padding: 1rem 1.5rem;
        border-top: 1px solid var(--border-color, #e5e7eb);
    }
</style>
{% endblock %}

{% block content %}
<div class="detail-page">
    <div class="page-header">
        <div class="breadcrumb">
            {% if scan.queue %}
            <a href="{{ url_for('main.queues') }}">Queues</a> / 
            <a href="{{ url_for('main.queue_detail', queue_id=scan.queue.id) }}">{{ scan.queue.name or scan.queue.queue_id }}</a> / 
            {{ scan.scan_name or scan.scan_id }}
            {% else %}
            <a href="{{ url_for('main.scans') }}">Scans</a> / {{ scan.scan_name or scan.scan_id }}
            {% endif %}
        </div>
        <div class="header-actions">
            {% if scan.status == 'running' %}
            <span class="live-indicator">LIVE</span>
            {% endif %}
            <span id="connection-status" class="connection-status connecting" title="Connecting..."></span>
            <div class="detail-action-buttons">
                <a href="{{ scan.pybirch_uri }}" class="btn-icon-lg action-open" title="Open in PyBirch">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>
                </a>
                <button type="button" class="btn-icon-lg action-archive" title="Archive" onclick="archiveItem('scan', {{ scan.id }}, '{{ (scan.scan_name or scan.scan_id) | e }}')">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line></svg>
                </button>
                <button type="button" class="btn-icon-lg action-trash" title="Move to Trash" onclick="moveToTrash('scan', {{ scan.id }}, '{{ (scan.scan_name or scan.scan_id) | e }}')">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                </button>
            </div>
        </div>
    </div>
    
    <div class="detail-header">
        <h1>{{ scan.scan_name or 'Unnamed Scan' }}</h1>
        <span class="status-badge status-{{ scan.status }}" id="scan-status-badge">{{ scan.status }}</span>
        <span id="scan-status-message" class="status-message"></span>
    </div>
    
    <!-- Live Stats Panel (shown for running scans) -->
    {% if scan.status == 'running' %}
    <div class="data-summary" id="live-stats-panel" style="margin-bottom: 1rem;">
        <div class="data-summary-item">
            <div class="label">Elapsed Time</div>
            <div class="value" id="scan-elapsed-time">0s</div>
        </div>
        <div class="data-summary-item">
            <div class="label">Progress</div>
            <div class="value" id="scan-progress-percent">0%</div>
        </div>
        <div class="data-summary-item">
            <div class="label">Live Data Points</div>
            <div class="value" id="live-data-count">0</div>
        </div>
    </div>
    {% endif %}
    
    <div class="detail-grid">
        <div class="detail-section">
            <h2>Scan Information</h2>
            <dl class="detail-list">
                <dt>Scan ID</dt>
                <dd>{{ scan.scan_id or '-' }}</dd>
                
                <dt>Project</dt>
                <dd>{{ scan.project_name or '-' }}</dd>
                
                <dt>Operator</dt>
                <dd>{{ scan.created_by or '-' }}</dd>
                
                <dt>Scan Type</dt>
                <dd>{{ scan.scan_type or '-' }}</dd>
                
                <dt>Job Type</dt>
                <dd>{{ scan.job_type or '-' }}</dd>
                
                <dt>Start Time</dt>
                <dd>{{ scan.started_at[:19] if scan.started_at else '-' }}</dd>
                
                <dt>End Time</dt>
                <dd>{{ scan.completed_at[:19] if scan.completed_at else '-' }}</dd>
            </dl>
        </div>
        
        <div class="detail-section">
            <h2>Parent Queue</h2>
            {% if scan.queue %}
                <dl class="detail-list">
                    <dt>Queue Name</dt>
                    <dd><a href="{{ url_for('main.queue_detail', queue_id=scan.queue.id) }}">{{ scan.queue.name or scan.queue.queue_id }}</a></dd>
                    
                    <dt>Queue ID</dt>
                    <dd>{{ scan.queue.queue_id or '-' }}</dd>
                    
                    <dt>Status</dt>
                    <dd><span class="status-badge status-{{ scan.queue.status }}">{{ scan.queue.status }}</span></dd>
                    
                    <dt>Progress</dt>
                    <dd>{{ scan.queue.completed_scans or 0 }} / {{ scan.queue.total_scans or 0 }} scans</dd>
                </dl>
            {% else %}
                <p class="empty-state">This scan is not part of a queue.</p>
            {% endif %}
        </div>
        
        <div class="detail-section">
            <div class="section-header-inline">
                <h2>Linked Entities</h2>
                <button type="button" class="btn btn-sm btn-secondary" onclick="openEditLinksModal()">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                    Edit
                </button>
            </div>
            <dl class="detail-list">
                <dt>Sample</dt>
                <dd>
                    {% if scan.sample %}
                        <a href="{{ url_for('main.sample_detail', sample_id=scan.sample.id) }}">{{ scan.sample.sample_id }}</a>
                        {% if scan.sample.name %}<span class="text-muted"> - {{ scan.sample.name }}</span>{% endif %}
                    {% else %}
                        <span class="text-muted">None</span>
                    {% endif %}
                </dd>
                
                <dt>Project</dt>
                <dd>
                    {% if scan.project %}
                        <a href="{{ url_for('main.project_detail', project_id=scan.project.id) }}">{{ scan.project.name }}</a>
                        {% if scan.project.code %}<span class="text-muted"> ({{ scan.project.code }})</span>{% endif %}
                    {% else %}
                        <span class="text-muted">None</span>
                    {% endif %}
                </dd>
            </dl>
            
            <h3>PyBirch URI</h3>
            <div class="uri-box">
                <code>{{ scan.pybirch_uri }}</code>
                <button class="btn btn-sm copy-btn" data-copy="{{ scan.pybirch_uri }}">Copy</button>
            </div>
        </div>
    </div>
    
    <!-- Measurement Objects Overview -->
    {% if scan.measurement_objects %}
    <div class="related-section">
        <h2>Measurement Objects ({{ scan.measurement_objects|length }})</h2>
        <table class="data-table">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Columns</th>
                    <th>Unit</th>
                    <th>Instrument</th>
                    <th>Data Points</th>
                </tr>
            </thead>
            <tbody>
                {% for mo in scan.measurement_objects %}
                <tr>
                    <td>{{ mo.name }}</td>
                    <td>{{ mo.columns | join(', ') if mo.columns else '-' }}</td>
                    <td>{{ mo.unit or '-' }}</td>
                    <td>{{ mo.instrument_name or '-' }}</td>
                    <td>{{ visualization_data[mo.name].point_count if visualization_data and mo.name in visualization_data else '-' }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
    {% endif %}
    
    <!-- Data Visualization Section -->
    {% if visualization_data %}
    <div class="related-section">
        <h2>Data Visualization</h2>
        
        <!-- Global Visualization Actions -->
        <div class="viz-controls">
            <div class="viz-control-group">
                <label>Scan Data</label>
            </div>
            <div class="viz-action-buttons">
                {% if scan.sample %}
                <button type="button" class="viz-action-btn btn-save-to-sample save-to-sample-btn" 
                        data-measurement="global"
                        data-measurement-name="All Data"
                        data-sample-id="{{ scan.sample.id }}"
                        data-sample-name="{{ scan.sample.sample_id }}"
                        data-scan-name="{{ scan.scan_name or scan.scan_id }}"
                        title="Save visualization to {{ scan.sample.sample_id }}">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="2" y="2" width="12" height="12" rx="1"/>
                        <path d="M5 5h6M5 8h4"/>
                        <circle cx="10.5" cy="10.5" r="1.5"/>
                    </svg>
                </button>
                {% else %}
                <span class="save-hint" title="Link this scan to a sample to save visualizations">üí° Link to sample to save</span>
                {% endif %}
                <a href="{{ url_for('main.download_scan_csv', scan_id=scan.id) }}" class="viz-action-btn btn-download" title="Download CSV">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M8 2v8M5 7l3 3 3-3"/>
                        <path d="M2 11v2a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-2"/>
                    </svg>
                </a>
            </div>
        </div>
        
        {% if visualization_data|length > 1 %}
        <!-- Tabs for multiple measurement objects -->
        <div class="measurement-tabs" id="measurementTabs">
            {% for name, data in visualization_data.items() %}
            <button class="measurement-tab {% if loop.first %}active{% endif %}" 
                    data-target="measurement-{{ loop.index }}">
                {{ name }} ({{ data.point_count }} pts)
            </button>
            {% endfor %}
        </div>
        {% endif %}
        
        {% for name, data in visualization_data.items() %}
        <div class="measurement-section {% if loop.first %}active{% endif %}" id="measurement-{{ loop.index }}">
            <div class="chart-wrapper">
                <div class="chart-header">
                    <h3>{{ name }}</h3>
                    <div class="chart-meta">
                        {% if data.instrument_name %}
                        <span>Instrument: {{ data.instrument_name }}</span>
                        {% endif %}
                        {% if data.unit %}
                        <span>Unit: {{ data.unit }}</span>
                        {% endif %}
                        <span>{{ data.point_count }} points</span>
                    </div>
                </div>
                
                {% if data.columns and data.columns|length >= 2 %}
                <!-- Visualization Controls -->
                <div class="viz-controls">
                    <div class="viz-control-group">
                        <label>Type:</label>
                        <select class="viz-type-select" data-chart="chart-{{ loop.index }}" data-measurement="{{ loop.index }}">
                            <option value="line">üìà Line</option>
                            <option value="scatter">‚ö´ Scatter</option>
                            <option value="heatmap">üó∫Ô∏è Heatmap</option>
                        </select>
                    </div>
                    <div class="viz-control-group">
                        <label>X-Axis:</label>
                        <select class="x-axis-select" data-chart="chart-{{ loop.index }}">
                            {% for col in data.columns %}
                            <option value="{{ col }}" {% if col == data.x_column %}selected{% endif %}>{{ col }}</option>
                            {% endfor %}
                            <option value="sequence_index">Sequence Index</option>
                        </select>
                    </div>
                    <div class="viz-control-group">
                        <label>Y-Axis:</label>
                        <select class="y-axis-select" data-chart="chart-{{ loop.index }}">
                            {% for col in data.columns %}
                            <option value="{{ col }}" {% if col == data.y_column %}selected{% endif %}>{{ col }}</option>
                            {% endfor %}
                        </select>
                    </div>
                    <div class="viz-control-group heatmap-only" style="display: none;" data-measurement="{{ loop.index }}">
                        <label>Color:</label>
                        <select class="colorscale-select" data-measurement="{{ loop.index }}">
                            <option value="Viridis">Viridis</option>
                            <option value="Plasma">Plasma</option>
                            <option value="Inferno">Inferno</option>
                            <option value="Cividis">Cividis (colorblind)</option>
                            <option value="RdBu">Red-Blue</option>
                            <option value="Greys">Grayscale</option>
                        </select>
                    </div>
                    <div class="viz-control-group heatmap-only" style="display: none;" data-measurement="{{ loop.index }}">
                        <label>Z-Value:</label>
                        <select class="z-axis-select" data-chart="chart-{{ loop.index }}" data-measurement="{{ loop.index }}">
                            {% for col in data.columns %}
                            {% if col != data.x_column and col != data.y_column %}
                            <option value="{{ col }}">{{ col }}</option>
                            {% endif %}
                            {% endfor %}
                        </select>
                    </div>
                    <div class="viz-control-group line-scatter-only" data-measurement="{{ loop.index }}">
                        <label>Legend:</label>
                        <select class="legend-select" data-chart="chart-{{ loop.index }}" data-measurement="{{ loop.index }}">
                            <option value="">None</option>
                            {% for col in data.columns %}
                            {% if col != data.x_column and col != data.y_column %}
                            <option value="{{ col }}">{{ col }}</option>
                            {% endif %}
                            {% endfor %}
                        </select>
                    </div>
                    <div class="viz-control-group legend-colorscale-group line-scatter-only" style="display: none;" data-measurement="{{ loop.index }}">
                        <label>Legend Color:</label>
                        <select class="legend-colorscale-select" data-measurement="{{ loop.index }}">
                            <option value="Viridis">Viridis</option>
                            <option value="Plasma">Plasma</option>
                            <option value="Inferno">Inferno</option>
                            <option value="Cividis">Cividis (colorblind)</option>
                            <option value="RdBu">Red-Blue</option>
                            <option value="Greys">Grayscale</option>
                        </select>
                    </div>
                </div>
                
                <!-- Dimension Reduction Panel (shows when data has more dimensions than needed) -->
                {% if data.columns|length > 2 %}
                <div class="dim-reduction-panel" id="dim-reduction-{{ loop.index }}" data-measurement="{{ loop.index }}">
                    <div class="dim-reduction-header">
                        <h4>Dimension Reduction</h4>
                        <span class="dim-reduction-info">{{ data.columns|length }} columns - add reductions to visualize</span>
                    </div>
                    <div class="reductions-container" data-measurement="{{ loop.index }}">
                        <!-- Reduction rows will be added dynamically -->
                    </div>
                    <button class="add-reduction-btn" data-measurement="{{ loop.index }}">+ Add Reduction</button>
                </div>
                {% endif %}
                {% endif %}
                
                <!-- Data summary -->
                <div class="data-summary">
                    <div class="data-summary-item">
                        <div class="label">Total Points</div>
                        <div class="value">{{ data.point_count }}</div>
                    </div>
                    {% if data.data_points %}
                    <div class="data-summary-item">
                        <div class="label">X Range</div>
                        <div class="value" id="xrange-{{ loop.index }}">-</div>
                    </div>
                    <div class="data-summary-item">
                        <div class="label">Y Range</div>
                        <div class="value" id="yrange-{{ loop.index }}">-</div>
                    </div>
                    {% endif %}
                </div>
                
                {% if data.data_points %}
                <!-- Chart.js container (line/scatter) -->
                <div class="chart-view">
                    <div class="chart-container">
                        <canvas id="chart-{{ loop.index }}"></canvas>
                    </div>
                </div>
                <!-- Plotly heatmap container -->
                <div class="heatmap-view">
                    <div class="heatmap-container" id="heatmap-{{ loop.index }}"></div>
                </div>
                {% else %}
                <div class="no-data-message">No data points available for visualization.</div>
                {% endif %}
            </div>
            
            <!-- Data table -->
            {% if data.all_values %}
            <div class="chart-wrapper">
                <h3>Data Table ({{ data.columns | join(', ') if data.columns else 'values' }})</h3>
                <div class="table-scroll">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Index</th>
                                {% for col in data.columns %}
                                <th>{{ col }}{% if data.unit and loop.last %} ({{ data.unit }}){% endif %}</th>
                                {% endfor %}
                                <th>Timestamp</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for row in data.all_values[:100] %}
                            <tr>
                                <td>{{ row.sequence_index }}</td>
                                {% for col in data.columns %}
                                <td>{{ "%.6g" | format(row[col]) if row[col] is not none else '-' }}</td>
                                {% endfor %}
                                <td>{{ row.timestamp[:19] if row.timestamp else '-' }}</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
                {% if data.all_values|length > 100 %}
                <p class="note">Showing first 100 of {{ data.all_values|length }} data points.</p>
                {% endif %}
            </div>
            {% endif %}
        </div>
        {% endfor %}
    </div>
    {% else %}
    <div class="related-section">
        <h2>Data Visualization</h2>
        <p class="empty-state">No measurement data available for this scan.</p>
    </div>
    {% endif %}
    
    <!-- Scan Log Panel -->
    <div class="related-section">
        <div class="section-header">
            <h2>üìã Scan Log</h2>
            <button class="btn btn-sm btn-secondary" id="clear-scan-log-btn">Clear</button>
        </div>
        <div class="log-panel" id="scan-log-panel">
            {% if scan.logs %}
                {% for log in scan.logs %}
                <div class="log-entry {{ log.level }}">
                    <span class="log-timestamp">{{ log.timestamp[:19] if log.timestamp else '--:--:--' }}</span>
                    {% if log.phase %}<span class="log-phase">[{{ log.phase }}]</span>{% endif %}
                    <span class="log-level">[{{ log.level }}]</span>
                    {% if log.progress is not none %}<span class="log-progress">({{ "%.1f" | format(log.progress) }}%)</span>{% endif %}
                    {{ log.message }}
                </div>
                {% endfor %}
            {% else %}
                <div class="log-entry INFO"><span class="log-timestamp">--:--:--</span> No log entries yet</div>
            {% endif %}
        </div>
    </div>
</div>

<!-- Edit Links Modal -->
<div class="modal-overlay" id="edit-links-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Edit Linked Entities</h3>
            <button type="button" class="modal-close" onclick="closeEditLinksModal()">&times;</button>
        </div>
        <form action="{{ url_for('main.scan_edit_links', scan_id=scan.id) }}" method="POST">
            <div class="modal-body">
                <div class="form-group">
                    <label for="sample_id">Sample</label>
                    <select id="sample_id" name="sample_id" class="searchable-select" data-entity-type="sample">
                        <option value="">-- None --</option>
                        {% for sample in samples %}
                        <option value="{{ sample.id }}" {% if scan.sample_id == sample.id %}selected{% endif %}>
                            {{ sample.display }}
                        </option>
                        {% endfor %}
                    </select>
                    <small class="form-text">Link this scan to a sample</small>
                </div>
                <div class="form-group">
                    <label for="project_id">Project</label>
                    <select id="project_id" name="project_id" class="searchable-select" data-entity-type="project">
                        <option value="">-- None --</option>
                        {% for project in projects %}
                        <option value="{{ project.id }}" {% if scan.project_id == project.id %}selected{% endif %}>
                            {{ project.display }}
                        </option>
                        {% endfor %}
                    </select>
                    <small class="form-text">Link this scan to a project</small>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="closeEditLinksModal()">Cancel</button>
                <button type="submit" class="btn btn-primary">Save Changes</button>
            </div>
        </form>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    // ===== EDIT LINKS MODAL =====
    function openEditLinksModal() {
        document.getElementById('edit-links-modal').classList.add('active');
    }
    
    function closeEditLinksModal() {
        document.getElementById('edit-links-modal').classList.remove('active');
    }
    
    // Close modal on backdrop click
    document.getElementById('edit-links-modal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeEditLinksModal();
        }
    });
    
    // Close modal on Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            closeEditLinksModal();
        }
    });
    
    // Store visualization data from server
    const visualizationData = {{ visualization_data | tojson | safe if visualization_data else '{}' }};
    const charts = {};
    const heatmaps = {};
    const vizState = {}; // Track visualization state per measurement
    
    // Color palette for multiple datasets
    const colors = [
        { border: '#0078d4', bg: 'rgba(0, 120, 212, 0.1)' },
        { border: '#28a745', bg: 'rgba(40, 167, 69, 0.1)' },
        { border: '#dc3545', bg: 'rgba(220, 53, 69, 0.1)' },
        { border: '#ffc107', bg: 'rgba(255, 193, 7, 0.1)' },
        { border: '#6f42c1', bg: 'rgba(111, 66, 193, 0.1)' },
    ];
    
    // Initialize charts for each measurement object
    let chartIndex = 1;
    for (const [name, data] of Object.entries(visualizationData)) {
        if (data.data_points && data.data_points.length > 0) {
            // Initialize vizState with default axes
            vizState[chartIndex] = { 
                type: 'line', 
                colorscale: 'Viridis',
                xCol: data.x_column,
                yCol: data.y_column
            };
            createChart(`chart-${chartIndex}`, name, data, chartIndex);
        }
        chartIndex++;
    }
    
    function createChart(canvasId, name, data, index) {
        const ctx = document.getElementById(canvasId);
        if (!ctx) return;
        
        const xValues = data.data_points.map(p => p.x);
        const yValues = data.data_points.map(p => p.y);
        
        // Update range displays
        updateRangeDisplays(xValues, yValues, index);
        
        const colorIdx = (index - 1) % colors.length;
        
        // Determine chart type based on data
        const chartType = data.point_count > 50 ? 'line' : 'scatter';
        
        const chart = new Chart(ctx, {
            type: chartType,
            data: {
                datasets: [{
                    label: name,
                    data: data.data_points.map(p => ({ x: p.x, y: p.y })),
                    borderColor: colors[colorIdx].border,
                    backgroundColor: colors[colorIdx].bg,
                    fill: chartType === 'line',
                    tension: 0.1,
                    pointRadius: chartType === 'line' ? (data.point_count > 500 ? 0 : 2) : 3,
                    pointHoverRadius: 5,
                    borderWidth: 2,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: true, position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${data.x_column}: ${context.parsed.x.toFixed(6)}, ${data.y_column}: ${context.parsed.y.toFixed(6)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: data.x_column }
                    },
                    y: {
                        title: { display: true, text: data.y_column + (data.unit ? ` (${data.unit})` : '') }
                    }
                },
                interaction: { intersect: false, mode: 'nearest' }
            }
        });
        
        charts[canvasId] = { chart, data, name };
    }
    
    function updateRangeDisplays(xValues, yValues, index) {
        const validX = xValues.filter(v => v !== null && !isNaN(v));
        const validY = yValues.filter(v => v !== null && !isNaN(v));
        
        if (validX.length > 0) {
            const xMin = Math.min(...validX);
            const xMax = Math.max(...validX);
            const xRangeEl = document.getElementById(`xrange-${index}`);
            if (xRangeEl) xRangeEl.textContent = `${xMin.toFixed(4)} - ${xMax.toFixed(4)}`;
        }
        
        if (validY.length > 0) {
            const yMin = Math.min(...validY);
            const yMax = Math.max(...validY);
            const yRangeEl = document.getElementById(`yrange-${index}`);
            if (yRangeEl) yRangeEl.textContent = `${yMin.toFixed(4)} - ${yMax.toFixed(4)}`;
        }
    }
    
    // Create heatmap using Plotly
    function createHeatmap(containerId, data, index, colorscale = 'Viridis') {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        // For heatmaps, we need 2D grid data
        // Try to detect if data forms a grid, otherwise show as scatter heatmap
        const allValues = data.all_values || [];
        const state = vizState[index] || {};
        const xCol = state.xCol || data.x_column;
        const yCol = state.yCol || data.y_column;
        
        // Get unique x and y values
        const xVals = [...new Set(allValues.map(r => r[xCol]))].sort((a, b) => a - b);
        const yVals = [...new Set(allValues.map(r => r[yCol]))].sort((a, b) => a - b);
        
        // Check if we can form a grid
        const isGrid = xVals.length > 1 && yVals.length > 1 && xVals.length * yVals.length <= allValues.length * 2;
        
        let trace, layout;
        
        if (isGrid && xVals.length >= 2 && yVals.length >= 2) {
            // Create 2D heatmap grid
            const zGrid = [];
            const yValMap = new Map(yVals.map((v, i) => [v, i]));
            const xValMap = new Map(xVals.map((v, i) => [v, i]));
            
            // Initialize grid
            for (let i = 0; i < yVals.length; i++) {
                zGrid.push(new Array(xVals.length).fill(null));
            }
            
            // Fill in values (use first measurement column that's not x or y)
            const valueCol = data.columns.find(c => c !== xCol && c !== yCol) || yCol;
            
            allValues.forEach(row => {
                const xi = xValMap.get(row[xCol]);
                const yi = yValMap.get(row[yCol]);
                if (xi !== undefined && yi !== undefined) {
                    zGrid[yi][xi] = row[valueCol];
                }
            });
            
            trace = {
                z: zGrid,
                x: xVals,
                y: yVals,
                type: 'heatmap',
                colorscale: colorscale,
                hoverongaps: false,
                colorbar: { title: valueCol + (data.unit ? ` (${data.unit})` : '') }
            };
            
            layout = {
                title: data.name || 'Heatmap',
                xaxis: { title: xCol },
                yaxis: { title: yCol },
                margin: { t: 50, l: 60, r: 30, b: 50 }
            };
        } else {
            // Scatter plot with color representing value
            const valueCol = data.columns.find(c => c !== xCol && c !== yCol) || yCol;
            
            trace = {
                x: allValues.map(r => r[xCol]),
                y: allValues.map(r => r[yCol]),
                mode: 'markers',
                type: 'scatter',
                marker: {
                    color: allValues.map(r => r[valueCol]),
                    colorscale: colorscale,
                    showscale: true,
                    colorbar: { title: valueCol + (data.unit ? ` (${data.unit})` : '') },
                    size: 8
                },
                text: allValues.map(r => `${valueCol}: ${r[valueCol]?.toFixed(4) || 'N/A'}`),
                hovertemplate: `${xCol}: %{x}<br>${yCol}: %{y}<br>%{text}<extra></extra>`
            };
            
            layout = {
                title: data.name || 'Scatter Heatmap',
                xaxis: { title: xCol },
                yaxis: { title: yCol },
                margin: { t: 50, l: 60, r: 30, b: 50 }
            };
        }
        
        Plotly.newPlot(container, [trace], layout, { responsive: true });
        heatmaps[containerId] = { data, colorscale };
    }
    
    // Handle visualization type changes
    document.querySelectorAll('.viz-type-select').forEach(select => {
        select.addEventListener('change', function() {
            const measurementIndex = parseInt(this.dataset.measurement);
            const vizType = this.value;
            const section = this.closest('.measurement-section');
            const chartWrapper = section.querySelector('.chart-wrapper');
            const chartId = `chart-${measurementIndex}`;
            const chartInfo = charts[chartId];
            
            vizState[measurementIndex] = vizState[measurementIndex] || {};
            vizState[measurementIndex].type = vizType;
            
            // Toggle view visibility
            const chartView = chartWrapper.querySelector('.chart-view');
            const heatmapView = chartWrapper.querySelector('.heatmap-view');
            const heatmapOnlyControls = section.querySelectorAll(`.heatmap-only[data-measurement="${measurementIndex}"]`);
            const dimReductionPanel = section.querySelector(`.dim-reduction-panel[data-measurement="${measurementIndex}"]`);
            const reductionRows2 = section.querySelectorAll('.reduction-row-2');
            
            // Toggle line-scatter-only controls
            const lineScatterOnlyControls = section.querySelectorAll(`.line-scatter-only[data-measurement="${measurementIndex}"]`);
            
            if (vizType === 'heatmap') {
                if (chartView) chartView.style.display = 'none';
                if (heatmapView) heatmapView.style.display = 'block';
                heatmapOnlyControls.forEach(ctrl => ctrl.style.display = 'flex');
                lineScatterOnlyControls.forEach(ctrl => ctrl.style.display = 'none');
                if (dimReductionPanel) dimReductionPanel.classList.add('active');
                // Hide second reduction row for heatmaps (only need one reduction)
                reductionRows2.forEach(row => row.style.display = 'none');
                
                // Create heatmap if not exists
                const heatmapId = `heatmap-${measurementIndex}`;
                
                if (chartInfo && !heatmaps[heatmapId]) {
                    const reductions = getReductions(measurementIndex);
                    // For heatmap, only use first reduction
                    const heatmapReductions = reductions.length > 0 ? [reductions[0]] : [];
                    createReducedHeatmap(
                        heatmapId, chartInfo.data, measurementIndex,
                        vizState[measurementIndex].colorscale || 'Viridis',
                        heatmapReductions,
                        vizState[measurementIndex].zCol
                    );
                }
            } else {
                if (chartView) chartView.style.display = 'block';
                if (heatmapView) heatmapView.style.display = 'none';
                heatmapOnlyControls.forEach(ctrl => ctrl.style.display = 'none');
                lineScatterOnlyControls.forEach(ctrl => ctrl.style.display = 'flex');
                if (dimReductionPanel) dimReductionPanel.classList.add('active');
                // Show second reduction row for line/scatter with 4+ columns
                reductionRows2.forEach(row => {
                    row.style.display = (chartInfo && chartInfo.data.columns.length > 3) ? 'flex' : 'none';
                });
                
                // Update chart type (line vs scatter)
                if (chartInfo) {
                    chartInfo.chart.config.type = vizType;
                    // Refresh with any dimension reductions applied
                    refreshVisualization(measurementIndex);
                }
                
                // Update legend colorscale visibility based on legend selection
                const legendSelect = section.querySelector(`.legend-select[data-measurement="${measurementIndex}"]`);
                const legendColorscaleGroup = section.querySelector(`.legend-colorscale-group[data-measurement="${measurementIndex}"]`);
                if (legendSelect && legendColorscaleGroup) {
                    const hasLegend = legendSelect.value !== '';
                    const state = vizState[measurementIndex] || {};
                    const uniqueCount = state.legendUniqueCount || 0;
                    // Show colorscale selector only when legend has 10+ unique values
                    legendColorscaleGroup.style.display = (hasLegend && uniqueCount >= 10) ? 'flex' : 'none';
                }
            }
            
            // Update reduction UI since plot axes may have changed
            updateReductionUI(measurementIndex);
        });
    });
    
    // Handle color scale changes
    document.querySelectorAll('.colorscale-select').forEach(select => {
        select.addEventListener('change', function() {
            const measurementIndex = this.dataset.measurement;
            const colorscale = this.value;
            const heatmapId = `heatmap-${measurementIndex}`;
            const chartId = `chart-${measurementIndex}`;
            
            vizState[measurementIndex] = vizState[measurementIndex] || {};
            vizState[measurementIndex].colorscale = colorscale;
            
            // Update heatmap colorscale
            const container = document.getElementById(heatmapId);
            if (container && container.data && container.data.length > 0) {
                // Use trace index [0] for restyle
                Plotly.restyle(container, { colorscale: colorscale }, [0]);
            } else if (charts[chartId]) {
                // Heatmap doesn't exist yet, create it with new colorscale
                createHeatmap(heatmapId, charts[chartId].data, measurementIndex, colorscale);
            }
        });
    });
    
    // Handle axis selector changes
    document.querySelectorAll('.x-axis-select, .y-axis-select').forEach(select => {
        select.addEventListener('change', function() {
            const chartId = this.dataset.chart;
            const chartInfo = charts[chartId];
            if (!chartInfo) return;
            
            const container = this.closest('.measurement-section');
            const xSelect = container.querySelector('.x-axis-select');
            const ySelect = container.querySelector('.y-axis-select');
            
            const xCol = xSelect.value;
            const yCol = ySelect.value;
            const index = parseInt(chartId.split('-')[1]);
            
            // Store selected axes in vizState
            vizState[index] = vizState[index] || {};
            vizState[index].xCol = xCol;
            vizState[index].yCol = yCol;
            
            // Update chartInfo data references
            chartInfo.data.x_column = xCol;
            chartInfo.data.y_column = yCol;
            
            // Update legend select options to exclude x and y axes
            const legendSelect = container.querySelector(`.legend-select[data-measurement="${index}"]`);
            if (legendSelect) {
                const currentLegend = legendSelect.value;
                const columns = chartInfo.data.columns || [];
                const availableLegendCols = columns.filter(c => c !== xCol && c !== yCol);
                
                // Rebuild options
                legendSelect.innerHTML = '<option value="">None</option>';
                availableLegendCols.forEach(col => {
                    const opt = document.createElement('option');
                    opt.value = col;
                    opt.textContent = col;
                    if (col === currentLegend) opt.selected = true;
                    legendSelect.appendChild(opt);
                });
                
                // If current legend is now an axis, reset it
                if (currentLegend === xCol || currentLegend === yCol) {
                    legendSelect.value = '';
                    vizState[index].legendCol = null;
                    vizState[index].legendUniqueCount = 0;
                    // Hide legend colorscale group
                    const legendColorscaleGroup = container.querySelector(`.legend-colorscale-group[data-measurement="${index}"]`);
                    if (legendColorscaleGroup) legendColorscaleGroup.style.display = 'none';
                }
            }
            
            // Update z-axis select options to exclude x and y axes
            const zSelect = container.querySelector(`.z-axis-select[data-measurement="${index}"]`);
            if (zSelect) {
                const currentZ = zSelect.value;
                const columns = chartInfo.data.columns || [];
                const availableZCols = columns.filter(c => c !== xCol && c !== yCol);
                
                // Rebuild options
                zSelect.innerHTML = '';
                availableZCols.forEach(col => {
                    const opt = document.createElement('option');
                    opt.value = col;
                    opt.textContent = col;
                    if (col === currentZ && availableZCols.includes(currentZ)) opt.selected = true;
                    zSelect.appendChild(opt);
                });
                
                // If current Z is now an axis, reset to first available
                if (currentZ === xCol || currentZ === yCol) {
                    vizState[index].zCol = availableZCols[0] || null;
                }
            }
            
            // Update reduction UI since plot axes changed
            updateReductionUI(index);
            
            // Refresh visualization (handles both chart and heatmap, with legend support)
            refreshVisualization(index);
        });
    });
    
    // ===== DIMENSION REDUCTION FUNCTIONALITY =====
    
    // Generic dimension reduction function - can reduce one dimension
    function applyDimensionReduction(allValues, preserveCols, reduceCol, method, sliceIndex, sliceValues) {
        if (!reduceCol || preserveCols.includes(reduceCol)) {
            return allValues; // No reduction needed
        }
        
        // Get unique values for the dimension to reduce
        const reduceVals = sliceValues || [...new Set(allValues.map(r => r[reduceCol]))].sort((a, b) => a - b);
        
        if (method === 'slice') {
            // Filter to only rows matching the slice value
            const targetValue = reduceVals[Math.min(sliceIndex, reduceVals.length - 1)];
            return allValues.filter(row => row[reduceCol] === targetValue);
        }
        
        // For aggregation methods (max, min, avg), group by preserved columns and aggregate
        const grouped = new Map();
        allValues.forEach(row => {
            const key = preserveCols.map(c => row[c]).join('_');
            if (!grouped.has(key)) {
                const entry = { values: {}, timestamp: row.timestamp, sequence_index: row.sequence_index };
                preserveCols.forEach(c => entry[c] = row[c]);
                grouped.set(key, entry);
            }
            // Collect all values for aggregation
            const entry = grouped.get(key);
            Object.keys(row).forEach(col => {
                if (!preserveCols.includes(col) && col !== 'timestamp' && col !== 'sequence_index') {
                    if (!entry.values[col]) entry.values[col] = [];
                    if (row[col] !== null && row[col] !== undefined) {
                        entry.values[col].push(row[col]);
                    }
                }
            });
        });
        
        // Apply aggregation function
        const result = [];
        grouped.forEach((entry, key) => {
            const newRow = { timestamp: entry.timestamp, sequence_index: entry.sequence_index };
            preserveCols.forEach(c => newRow[c] = entry[c]);
            
            Object.keys(entry.values).forEach(col => {
                const vals = entry.values[col];
                if (vals && vals.length > 0) {
                    switch (method) {
                        case 'max': newRow[col] = Math.max(...vals); break;
                        case 'min': newRow[col] = Math.min(...vals); break;
                        case 'avg': newRow[col] = vals.reduce((a, b) => a + b, 0) / vals.length; break;
                        default: newRow[col] = vals[0];
                    }
                }
            });
            result.push(newRow);
        });
        
        return result;
    }
    
    // Apply multiple dimension reductions in sequence
    function applyMultipleReductions(allValues, preserveCols, reductions) {
        let data = allValues;
        for (const reduction of reductions) {
            if (reduction.reduceCol && !preserveCols.includes(reduction.reduceCol)) {
                data = applyDimensionReduction(data, preserveCols, reduction.reduceCol, reduction.method, reduction.sliceIndex, null);
            }
        }
        return data;
    }
    
    // Build title suffix from reductions
    function buildReductionTitle(reductions, allValues) {
        const parts = [];
        for (const r of reductions) {
            if (!r.reduceCol) continue;
            const reduceVals = [...new Set(allValues.map(row => row[r.reduceCol]))].sort((a, b) => a - b);
            if (r.method === 'slice' && reduceVals.length > 0) {
                const val = reduceVals[Math.min(r.sliceIndex || 0, reduceVals.length - 1)];
                parts.push(`${r.reduceCol}=${val?.toFixed?.(2) || val}`);
            } else if (r.method === 'max') {
                parts.push(`max(${r.reduceCol})`);
            } else if (r.method === 'min') {
                parts.push(`min(${r.reduceCol})`);
            } else if (r.method === 'avg') {
                parts.push(`avg(${r.reduceCol})`);
            }
        }
        return parts.length > 0 ? ` (${parts.join(', ')})` : '';
    }
    
    // Create heatmap with dimension reduction
    function createReducedHeatmap(containerId, data, index, colorscale, reductions, zCol) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        const allValues = data.all_values || [];
        const state = vizState[index] || {};
        const xCol = state.xCol || data.x_column;
        const yCol = state.yCol || data.y_column;
        const valueCol = zCol || state.zCol || data.columns.find(c => c !== xCol && c !== yCol) || yCol;
        
        // Apply all reductions
        const preserveCols = [xCol, yCol];
        const reducedData = reductions && reductions.length > 0 
            ? applyMultipleReductions(allValues, preserveCols, reductions)
            : allValues;
        
        // Get unique x and y values from reduced data
        const xVals = [...new Set(reducedData.map(r => r[xCol]))].sort((a, b) => a - b);
        const yVals = [...new Set(reducedData.map(r => r[yCol]))].sort((a, b) => a - b);
        
        let trace, layout;
        const isGrid = xVals.length > 1 && yVals.length > 1;
        
        // Build title suffix
        const titleSuffix = reductions ? buildReductionTitle(reductions, allValues) : '';
        
        if (isGrid && xVals.length >= 2 && yVals.length >= 2) {
            // Create 2D heatmap grid
            const zGrid = [];
            const yValMap = new Map(yVals.map((v, i) => [v, i]));
            const xValMap = new Map(xVals.map((v, i) => [v, i]));
            
            for (let i = 0; i < yVals.length; i++) {
                zGrid.push(new Array(xVals.length).fill(null));
            }
            
            reducedData.forEach(row => {
                const xi = xValMap.get(row[xCol]);
                const yi = yValMap.get(row[yCol]);
                if (xi !== undefined && yi !== undefined) {
                    zGrid[yi][xi] = row[valueCol];
                }
            });
            
            trace = {
                z: zGrid,
                x: xVals,
                y: yVals,
                type: 'heatmap',
                colorscale: colorscale,
                hoverongaps: false,
                colorbar: { title: valueCol + (data.unit ? ` (${data.unit})` : '') }
            };
            
            layout = {
                title: (data.name || 'Heatmap') + titleSuffix,
                xaxis: { title: xCol },
                yaxis: { title: yCol },
                margin: { t: 50, l: 60, r: 30, b: 50 }
            };
        } else {
            // Scatter with color
            trace = {
                x: reducedData.map(r => r[xCol]),
                y: reducedData.map(r => r[yCol]),
                mode: 'markers',
                type: 'scatter',
                marker: {
                    color: reducedData.map(r => r[valueCol]),
                    colorscale: colorscale,
                    showscale: true,
                    colorbar: { title: valueCol + (data.unit ? ` (${data.unit})` : '') },
                    size: 8
                },
                text: reducedData.map(r => `${valueCol}: ${r[valueCol]?.toFixed(4) || 'N/A'}`),
                hovertemplate: `${xCol}: %{x}<br>${yCol}: %{y}<br>%{text}<extra></extra>`
            };
            
            layout = {
                title: (data.name || 'Scatter') + titleSuffix,
                xaxis: { title: xCol },
                yaxis: { title: yCol },
                margin: { t: 50, l: 60, r: 30, b: 50 }
            };
        }
        
        Plotly.newPlot(container, [trace], layout, { responsive: true });
        heatmaps[containerId] = { data, colorscale, reductions, zCol: valueCol };
    }
    
    // Get current reductions from vizState (now uses dynamic array)
    function getReductions(measurementIndex) {
        const state = vizState[measurementIndex] || {};
        return state.reductions || [];
    }
    
    // Generate colors from a colorscale for legend
    function getColorsFromColorscale(colorscale, count) {
        // Colorscale definitions (simplified from Plotly)
        const scales = {
            'Viridis': [[0, '#440154'], [0.25, '#3b528b'], [0.5, '#21918c'], [0.75, '#5ec962'], [1, '#fde725']],
            'Plasma': [[0, '#0d0887'], [0.25, '#7e03a8'], [0.5, '#cc4778'], [0.75, '#f89540'], [1, '#f0f921']],
            'Inferno': [[0, '#000004'], [0.25, '#57106e'], [0.5, '#bc3754'], [0.75, '#f98e09'], [1, '#fcffa4']],
            'Cividis': [[0, '#00224e'], [0.25, '#3d4e67'], [0.5, '#7d7d7d'], [0.75, '#bea249'], [1, '#fee838']],
            'RdBu': [[0, '#053061'], [0.25, '#4393c3'], [0.5, '#f7f7f7'], [0.75, '#d6604d'], [1, '#67001f']],
            'Greys': [[0, '#ffffff'], [0.25, '#c0c0c0'], [0.5, '#808080'], [0.75, '#404040'], [1, '#000000']]
        };
        const scale = scales[colorscale] || scales['Viridis'];
        
        function interpolateColor(color1, color2, factor) {
            const hex2rgb = (hex) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return [r, g, b];
            };
            const rgb2hex = (r, g, b) => `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
            
            const [r1, g1, b1] = hex2rgb(color1);
            const [r2, g2, b2] = hex2rgb(color2);
            const r = Math.round(r1 + (r2 - r1) * factor);
            const g = Math.round(g1 + (g2 - g1) * factor);
            const b = Math.round(b1 + (b2 - b1) * factor);
            return rgb2hex(r, g, b);
        }
        
        function getColorAtPosition(pos) {
            for (let i = 0; i < scale.length - 1; i++) {
                if (pos >= scale[i][0] && pos <= scale[i + 1][0]) {
                    const factor = (pos - scale[i][0]) / (scale[i + 1][0] - scale[i][0]);
                    return interpolateColor(scale[i][1], scale[i + 1][1], factor);
                }
            }
            return scale[scale.length - 1][1];
        }
        
        const colors = [];
        for (let i = 0; i < count; i++) {
            const pos = count > 1 ? i / (count - 1) : 0.5;
            colors.push(getColorAtPosition(pos));
        }
        return colors;
    }
    
    // Sort legend values - numeric or alphabetic
    function sortLegendValues(values) {
        // Check if all values are numeric
        const allNumeric = values.every(v => !isNaN(parseFloat(v)) && isFinite(v));
        if (allNumeric) {
            return [...values].sort((a, b) => parseFloat(a) - parseFloat(b));
        }
        return [...values].sort((a, b) => String(a).localeCompare(String(b)));
    }
    
    // Refresh the current visualization with updated reductions
    function refreshVisualization(measurementIndex) {
        const chartId = `chart-${measurementIndex}`;
        const heatmapId = `heatmap-${measurementIndex}`;
        const chartInfo = charts[chartId];
        if (!chartInfo) return;
        
        const state = vizState[measurementIndex] || {};
        const reductions = getReductions(measurementIndex);
        
        // Use vizState for current axis selections, fallback to chartInfo.data
        const xCol = state.xCol || chartInfo.data.x_column;
        const yCol = state.yCol || chartInfo.data.y_column;
        
        if (state.type === 'heatmap') {
            createReducedHeatmap(
                heatmapId, chartInfo.data, measurementIndex,
                state.colorscale || 'Viridis',
                reductions,
                state.zCol
            );
        } else {
            // Line/scatter - apply reductions and update chart
            const allValues = chartInfo.data.all_values || [];
            const legendCol = state.legendCol;
            
            const preserveCols = [xCol];
            const reducedData = reductions.length > 0 
                ? applyMultipleReductions(allValues, preserveCols, reductions)
                : allValues;
            
            // Get the section element for manipulating views
            const section = document.querySelector(`.measurement-section#measurement-${measurementIndex}`);
            const chartView = section ? section.querySelector('.chart-view') : null;
            const heatmapView = section ? section.querySelector('.heatmap-view') : null;
            const heatmapContainer = document.getElementById(heatmapId);
            
            if (legendCol) {
                // Group data by legend column
                const uniqueLegendValues = sortLegendValues([...new Set(reducedData.map(r => r[legendCol]))]);
                const legendCount = uniqueLegendValues.length;
                const legendColorscale = state.legendColorscale || 'Viridis';
                const legendColors = getColorsFromColorscale(legendColorscale, legendCount);
                
                if (legendCount < 10) {
                    // Use Chart.js with regular legend (<10 groups)
                    if (chartView) chartView.style.display = 'block';
                    if (heatmapView) heatmapView.style.display = 'none';
                    
                    // Create datasets for each legend group
                    const datasets = uniqueLegendValues.map((legendValue, i) => {
                        const groupData = reducedData.filter(r => r[legendCol] === legendValue);
                        const color = legendColors[i];
                        return {
                            label: `${legendCol}=${legendValue}`,
                            data: groupData.map(row => ({
                                x: xCol === 'sequence_index' ? row.sequence_index : row[xCol],
                                y: row[yCol],
                                _sourceData: row  // Store source data for tooltips
                            })),
                            borderColor: color,
                            backgroundColor: color + '40', // 25% opacity
                            fill: state.type === 'line',
                            tension: 0.1,
                            pointRadius: state.type === 'line' ? 2 : 4,
                            pointHoverRadius: 6,
                            borderWidth: 2
                        };
                    });
                    
                    chartInfo.chart.data.datasets = datasets;
                    chartInfo.chart.options.scales.x.title.text = xCol;
                    chartInfo.chart.options.scales.y.title.text = yCol + (chartInfo.data.unit ? ` (${chartInfo.data.unit})` : '');
                    chartInfo.chart.options.plugins.legend = {
                        display: true,
                        position: 'top',
                        labels: { usePointStyle: true }
                    };
                    chartInfo.chart.options.plugins.tooltip = {
                        callbacks: {
                            label: function(context) {
                                const data = context.raw._sourceData || {};
                                const cols = chartInfo.data.columns || [];
                                let label = `${xCol}: ${context.parsed.x?.toFixed(4)}, ${yCol}: ${context.parsed.y?.toFixed(4)}`;
                                if (legendCol) label += `, ${legendCol}: ${data[legendCol]}`;
                                return label;
                            },
                            afterLabel: function(context) {
                                const data = context.raw._sourceData || {};
                                // Show additional data columns in tooltip
                                const cols = chartInfo.data.columns || [];
                                const extraCols = cols.filter(c => c !== xCol && c !== yCol && c !== legendCol);
                                if (extraCols.length > 0) {
                                    return extraCols.map(c => `${c}: ${data[c]?.toFixed?.(4) || data[c] || 'N/A'}`).join('\n');
                                }
                                return '';
                            }
                        }
                    };
                    chartInfo.chart.update();
                    
                    // Update ranges
                    const allDataPoints = datasets.flatMap(ds => ds.data);
                    updateRangeDisplays(allDataPoints.map(p => p.x), allDataPoints.map(p => p.y), measurementIndex);
                } else {
                    // Use Plotly with colorbar legend (>=10 groups)
                    if (chartView) chartView.style.display = 'none';
                    if (heatmapView) heatmapView.style.display = 'block';
                    
                    // Create value mapping for colorscale
                    const legendValueMap = new Map(uniqueLegendValues.map((v, i) => [v, i]));
                    const numericValues = reducedData.map(r => legendValueMap.get(r[legendCol]));
                    
                    // Determine if legend values are numeric for tick labels
                    const allNumeric = uniqueLegendValues.every(v => !isNaN(parseFloat(v)) && isFinite(v));
                    
                    const trace = {
                        x: reducedData.map(r => xCol === 'sequence_index' ? r.sequence_index : r[xCol]),
                        y: reducedData.map(r => r[yCol]),
                        mode: state.type === 'line' ? 'lines+markers' : 'markers',
                        type: 'scatter',
                        marker: {
                            color: numericValues,
                            colorscale: legendColorscale,
                            showscale: true,
                            colorbar: {
                                title: legendCol,
                                tickvals: allNumeric ? null : uniqueLegendValues.map((v, i) => i),
                                ticktext: allNumeric ? null : uniqueLegendValues.map(v => String(v).length > 10 ? String(v).slice(0, 10) + '...' : String(v))
                            },
                            size: state.type === 'line' ? 5 : 8
                        },
                        text: reducedData.map(r => {
                            const cols = chartInfo.data.columns || [];
                            const parts = cols.map(c => `${c}: ${r[c]?.toFixed?.(4) || r[c] || 'N/A'}`);
                            return parts.join('<br>');
                        }),
                        hovertemplate: `${xCol}: %{x}<br>${yCol}: %{y}<br>%{text}<extra></extra>`
                    };
                    
                    const layout = {
                        title: (chartInfo.name || 'Plot') + buildReductionTitle(reductions, allValues),
                        xaxis: { title: xCol },
                        yaxis: { title: yCol + (chartInfo.data.unit ? ` (${chartInfo.data.unit})` : '') },
                        margin: { t: 50, l: 60, r: 100, b: 50 }
                    };
                    
                    Plotly.newPlot(heatmapContainer, [trace], layout, { responsive: true });
                    
                    // Update ranges
                    updateRangeDisplays(
                        reducedData.map(r => xCol === 'sequence_index' ? r.sequence_index : r[xCol]),
                        reducedData.map(r => r[yCol]),
                        measurementIndex
                    );
                }
            } else {
                // No legend - original single dataset behavior
                if (chartView) chartView.style.display = 'block';
                if (heatmapView) heatmapView.style.display = 'none';
                
                const newData = reducedData.map(row => ({
                    x: xCol === 'sequence_index' ? row.sequence_index : row[xCol],
                    y: row[yCol],
                    _sourceData: row
                }));
                
                // Reset to single dataset
                chartInfo.chart.data.datasets = [{
                    label: chartInfo.name + buildReductionTitle(reductions, allValues),
                    data: newData,
                    borderColor: colors[0].border,
                    backgroundColor: colors[0].bg,
                    fill: state.type === 'line',
                    tension: 0.1,
                    pointRadius: state.type === 'line' ? (reducedData.length > 500 ? 0 : 2) : 3,
                    pointHoverRadius: 5,
                    borderWidth: 2
                }];
                
                chartInfo.chart.options.scales.x.title.text = xCol;
                chartInfo.chart.options.scales.y.title.text = yCol + (chartInfo.data.unit ? ` (${chartInfo.data.unit})` : '');
                chartInfo.chart.options.plugins.legend = { display: true, position: 'top' };
                chartInfo.chart.options.plugins.tooltip = {
                    callbacks: {
                        label: function(context) {
                            return `${xCol}: ${context.parsed.x?.toFixed(6)}, ${yCol}: ${context.parsed.y?.toFixed(6)}`;
                        },
                        afterLabel: function(context) {
                            const data = context.raw._sourceData || {};
                            const cols = chartInfo.data.columns || [];
                            const extraCols = cols.filter(c => c !== xCol && c !== yCol);
                            if (extraCols.length > 0) {
                                return extraCols.map(c => `${c}: ${data[c]?.toFixed?.(4) || data[c] || 'N/A'}`).join('\n');
                            }
                            return '';
                        }
                    }
                };
                chartInfo.chart.update();
                
                // Update ranges
                const xValues = newData.map(p => p.x);
                const yValues = newData.map(p => p.y);
                updateRangeDisplays(xValues, yValues, measurementIndex);
            }
        }
    }
    
    // Get columns that can be reduced (excludes plot axes)
    function getReducibleColumns(measurementIndex) {
        const chartId = `chart-${measurementIndex}`;
        const chartInfo = charts[chartId];
        if (!chartInfo) return [];
        
        const columns = chartInfo.data.columns || [];
        const state = vizState[measurementIndex] || {};
        // Use vizState for current axis selections, fallback to chartInfo.data
        const xCol = state.xCol || chartInfo.data.x_column;
        const yCol = state.yCol || chartInfo.data.y_column;
        const zCol = state.zCol || columns.find(c => c !== xCol && c !== yCol);
        const legendCol = state.legendCol;
        const isHeatmap = state.type === 'heatmap';
        
        // Exclude X and Y axes, Z for heatmaps, and legend column for line/scatter
        let axisColumns = isHeatmap ? [xCol, yCol, zCol] : [xCol, yCol];
        if (!isHeatmap && legendCol) {
            axisColumns.push(legendCol);
        }
        return columns.filter(c => !axisColumns.includes(c));
    }
    
    // Get columns that still need reduction for current visualization
    function getUnreducedColumns(measurementIndex) {
        const reducibleCols = getReducibleColumns(measurementIndex);
        const state = vizState[measurementIndex] || {};
        const reductions = state.reductions || [];
        // Only count reductions that target reducible columns (not axis conflicts)
        const validReducedCols = reductions.map(r => r.reduceCol).filter(c => reducibleCols.includes(c));
        return reducibleCols.filter(c => !validReducedCols.includes(c));
    }
    
    // Get reductions that are targeting axis columns (conflicts)
    function getConflictingReductions(measurementIndex) {
        const reducibleCols = getReducibleColumns(measurementIndex);
        const state = vizState[measurementIndex] || {};
        const reductions = state.reductions || [];
        // Find reductions that target non-reducible columns (axis columns)
        return reductions.filter(r => !reducibleCols.includes(r.reduceCol));
    }
    
    // Check if more reductions can be added
    function canAddReduction(measurementIndex) {
        const unreducedCols = getUnreducedColumns(measurementIndex);
        return unreducedCols.length > 0;
    }
    
    // Check if there are too many reductions for the current visualization
    function isOverreduced(measurementIndex) {
        const reducibleCols = getReducibleColumns(measurementIndex);
        const state = vizState[measurementIndex] || {};
        const reductions = state.reductions || [];
        // Overreduced if we have more reductions than reducible columns
        return reductions.length > reducibleCols.length;
    }
    
    // Get count of excess reductions
    function getExcessReductions(measurementIndex) {
        const reducibleCols = getReducibleColumns(measurementIndex);
        const state = vizState[measurementIndex] || {};
        const reductions = state.reductions || [];
        return Math.max(0, reductions.length - reducibleCols.length);
    }
    
    // Update the Add Reduction button state and info text
    function updateReductionUI(measurementIndex) {
        const section = document.querySelector(`.measurement-section#measurement-${measurementIndex}`);
        if (!section) return;
        
        const addBtn = section.querySelector('.add-reduction-btn');
        const infoSpan = section.querySelector('.dim-reduction-info');
        const chartInfo = charts[`chart-${measurementIndex}`];
        if (!chartInfo) return;
        
        const state = vizState[measurementIndex] || {};
        const reducibleCols = getReducibleColumns(measurementIndex);
        const unreducedCols = getUnreducedColumns(measurementIndex);
        const reductions = state.reductions || [];
        const conflictingReductions = getConflictingReductions(measurementIndex);
        const overreduced = isOverreduced(measurementIndex);
        const excessCount = getExcessReductions(measurementIndex);
        const hasConflicts = conflictingReductions.length > 0;
        
        // Update button state
        if (addBtn) {
            if (overreduced || hasConflicts) {
                // Can't add more when overreduced or has conflicts
                addBtn.disabled = true;
                if (hasConflicts) {
                    addBtn.textContent = `Fix ${conflictingReductions.length} conflicting reduction${conflictingReductions.length > 1 ? 's' : ''}`;
                } else {
                    addBtn.textContent = `Remove ${excessCount} reduction${excessCount > 1 ? 's' : ''} first`;
                }
                addBtn.classList.add('disabled');
            } else if (unreducedCols.length === 0) {
                addBtn.disabled = true;
                addBtn.textContent = 'All dimensions reduced';
                addBtn.classList.add('disabled');
            } else {
                addBtn.disabled = false;
                addBtn.textContent = `+ Add Reduction (${unreducedCols.length} available)`;
                addBtn.classList.remove('disabled');
            }
        }
        
        // Update info text
        if (infoSpan) {
            const totalCols = chartInfo.data.columns.length;
            const xCol = state.xCol || chartInfo.data.x_column;
            const yCol = state.yCol || chartInfo.data.y_column;
            const zCol = state.zCol || chartInfo.data.columns.find(c => c !== xCol && c !== yCol);
            const isHeatmap = state.type === 'heatmap';
            
            if (hasConflicts) {
                // Reductions targeting axis columns
                const conflictCols = conflictingReductions.map(r => r.reduceCol);
                infoSpan.textContent = `${totalCols} columns ‚Äî CONFLICT: reduction${conflictCols.length > 1 ? 's' : ''} on axis column${conflictCols.length > 1 ? 's' : ''}: ${conflictCols.join(', ')}`;
                infoSpan.style.color = '#dc3545'; // Red/error color
            } else if (overreduced) {
                // Too many reductions for current visualization type
                infoSpan.textContent = `${totalCols} columns ‚Äî OVERREDUCED: remove ${excessCount} reduction${excessCount > 1 ? 's' : ''} for ${isHeatmap ? 'heatmap' : 'line/scatter'}`;
                infoSpan.style.color = '#dc3545'; // Red/error color
            } else if (unreducedCols.length > 0) {
                infoSpan.textContent = `${totalCols} columns ‚Äî ${unreducedCols.length} need reduction: ${unreducedCols.join(', ')}`;
                infoSpan.style.color = '#ffc107'; // Warning color
            } else if (reductions.length > 0) {
                infoSpan.textContent = `${totalCols} columns ‚Äî ${reductions.length} reduction${reductions.length > 1 ? 's' : ''} applied`;
                infoSpan.style.color = '#28a745'; // Success color
            } else {
                infoSpan.textContent = `${totalCols} columns ‚Äî ready to visualize`;
                infoSpan.style.color = '';
            }
        }
    }
    
    // Create a reduction row HTML element (only includes reducible columns)
    function createReductionRow(measurementIndex, reductionIndex, reducibleColumns, defaultCol) {
        const row = document.createElement('div');
        row.className = 'reduction-row';
        row.dataset.reductionIndex = reductionIndex;
        row.dataset.measurement = measurementIndex;
        
        // Column select (only reducible columns, not plot axes)
        const selectGroup = document.createElement('div');
        selectGroup.className = 'viz-control-group';
        const label = document.createElement('label');
        label.textContent = 'Reduce:';
        const select = document.createElement('select');
        select.className = 'reduce-dim-select';
        select.dataset.measurement = measurementIndex;
        select.dataset.reductionIndex = reductionIndex;
        reducibleColumns.forEach((col, i) => {
            const opt = document.createElement('option');
            opt.value = col;
            opt.textContent = col;
            if (col === defaultCol) opt.selected = true;
            select.appendChild(opt);
        });
        selectGroup.appendChild(label);
        selectGroup.appendChild(select);
        row.appendChild(selectGroup);
        
        // Method buttons
        const methodGroup = document.createElement('div');
        methodGroup.className = 'reduction-method-group';
        ['slice', 'max', 'min', 'avg'].forEach((method, i) => {
            const btn = document.createElement('button');
            btn.className = 'reduction-method-btn' + (method === 'slice' ? ' active' : '');
            btn.dataset.method = method;
            btn.dataset.measurement = measurementIndex;
            btn.dataset.reductionIndex = reductionIndex;
            btn.textContent = method.charAt(0).toUpperCase() + method.slice(1);
            methodGroup.appendChild(btn);
        });
        row.appendChild(methodGroup);
        
        // Slice slider container
        const sliderContainer = document.createElement('div');
        sliderContainer.className = 'slice-slider-container active';
        sliderContainer.dataset.reductionIndex = reductionIndex;
        const sliderLabel = document.createElement('label');
        sliderLabel.textContent = 'Pos:';
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.className = 'slice-slider';
        slider.min = 0;
        slider.max = 100;
        slider.value = 50;
        slider.dataset.measurement = measurementIndex;
        slider.dataset.reductionIndex = reductionIndex;
        const sliceValue = document.createElement('span');
        sliceValue.className = 'slice-value';
        sliceValue.textContent = '50%';
        sliderContainer.appendChild(sliderLabel);
        sliderContainer.appendChild(slider);
        sliderContainer.appendChild(sliceValue);
        row.appendChild(sliderContainer);
        
        // Dim info
        const dimInfo = document.createElement('span');
        dimInfo.className = 'dim-info';
        row.appendChild(dimInfo);
        
        // Remove button
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-reduction-btn';
        removeBtn.textContent = '‚úï';
        removeBtn.dataset.measurement = measurementIndex;
        removeBtn.dataset.reductionIndex = reductionIndex;
        row.appendChild(removeBtn);
        
        return row;
    }
    
    // Add a new reduction for a measurement
    function addReduction(measurementIndex) {
        measurementIndex = parseInt(measurementIndex); // Ensure it's a number
        const section = document.querySelector(`.measurement-section#measurement-${measurementIndex}`);
        if (!section) {
            console.error('addReduction: section not found for', measurementIndex);
            return;
        }
        
        const container = section.querySelector('.reductions-container');
        if (!container) {
            console.error('addReduction: container not found');
            return;
        }
        
        const chartId = `chart-${measurementIndex}`;
        const chartInfo = charts[chartId];
        if (!chartInfo) {
            console.error('addReduction: chartInfo not found for', chartId, 'Available:', Object.keys(charts));
            return;
        }
        
        // Check if we can add more reductions
        if (!canAddReduction(measurementIndex)) {
            console.log('Cannot add more reductions - all reducible columns are already reduced');
            return;
        }
        
        // Initialize vizState
        vizState[measurementIndex] = vizState[measurementIndex] || {};
        vizState[measurementIndex].reductions = vizState[measurementIndex].reductions || [];
        
        const reductionIndex = vizState[measurementIndex].reductions.length;
        
        // Get reducible columns (excludes plot axes) and find one not already reduced
        const reducibleCols = getReducibleColumns(measurementIndex);
        const usedCols = vizState[measurementIndex].reductions.map(r => r.reduceCol);
        const availableCols = reducibleCols.filter(c => !usedCols.includes(c));
        
        if (availableCols.length === 0) {
            console.log('No available columns to reduce');
            return;
        }
        
        const defaultCol = availableCols[0];
        
        // Create the row element with only reducible columns
        const row = createReductionRow(measurementIndex, reductionIndex, reducibleCols, defaultCol);
        container.appendChild(row);
        
        // Initialize the reduction state
        const allValues = chartInfo.data.all_values || [];
        const reduceVals = [...new Set(allValues.map(r => r[defaultCol]))].sort((a, b) => a - b);
        const sliceIndex = Math.floor(reduceVals.length / 2);
        
        vizState[measurementIndex].reductions.push({
            reduceCol: defaultCol,
            method: 'slice',
            sliceIndex: sliceIndex,
            reduceVals: reduceVals
        });
        
        // Update slider and display
        const slider = row.querySelector('.slice-slider');
        const sliceValueSpan = row.querySelector('.slice-value');
        const dimInfo = row.querySelector('.dim-info');
        
        if (slider && reduceVals.length > 0) {
            slider.max = reduceVals.length - 1;
            slider.value = sliceIndex;
            if (sliceValueSpan) sliceValueSpan.textContent = reduceVals[sliceIndex]?.toFixed(3) || reduceVals[sliceIndex];
            if (dimInfo) dimInfo.textContent = `${reduceVals.length} values`;
        }
        
        // Attach event handlers
        attachReductionHandlers(row, measurementIndex, reductionIndex);
        
        // Update UI state (button, info text)
        updateReductionUI(measurementIndex);
        
        // Refresh visualization
        refreshVisualization(measurementIndex);
    }
    
    // Remove a reduction
    function removeReduction(measurementIndex, reductionIndex) {
        measurementIndex = parseInt(measurementIndex);
        reductionIndex = parseInt(reductionIndex);
        
        const section = document.querySelector(`.measurement-section#measurement-${measurementIndex}`);
        if (!section) return;
        
        const container = section.querySelector('.reductions-container');
        if (!container) return;
        
        // Remove from vizState
        vizState[measurementIndex] = vizState[measurementIndex] || {};
        vizState[measurementIndex].reductions = vizState[measurementIndex].reductions || [];
        vizState[measurementIndex].reductions.splice(reductionIndex, 1);
        
        // Remove the row element
        const row = container.querySelector(`.reduction-row[data-reduction-index="${reductionIndex}"]`);
        if (row) row.remove();
        
        // Re-index remaining rows
        container.querySelectorAll('.reduction-row').forEach((row, i) => {
            row.dataset.reductionIndex = i;
            row.querySelectorAll('[data-reduction-index]').forEach(el => el.dataset.reductionIndex = i);
        });
        
        // Update UI state (button, info text)
        updateReductionUI(measurementIndex);
        
        // Refresh visualization
        refreshVisualization(measurementIndex);
    }
    
    // Attach event handlers to a reduction row
    function attachReductionHandlers(row, measurementIndex, reductionIndex) {
        const chartId = `chart-${measurementIndex}`;
        const chartInfo = charts[chartId];
        if (!chartInfo) return;
        
        // Column select change
        const select = row.querySelector('.reduce-dim-select');
        if (select) {
            select.addEventListener('change', function() {
                const idx = parseInt(this.dataset.reductionIndex);
                const reduceCol = this.value;
                
                vizState[measurementIndex].reductions[idx].reduceCol = reduceCol;
                
                // Update slider for new column
                const allValues = chartInfo.data.all_values || [];
                const reduceVals = [...new Set(allValues.map(r => r[reduceCol]))].sort((a, b) => a - b);
                vizState[measurementIndex].reductions[idx].reduceVals = reduceVals;
                
                const slider = row.querySelector('.slice-slider');
                const sliceValueSpan = row.querySelector('.slice-value');
                const dimInfo = row.querySelector('.dim-info');
                
                if (slider && reduceVals.length > 0) {
                    slider.max = reduceVals.length - 1;
                    slider.value = Math.floor(reduceVals.length / 2);
                    vizState[measurementIndex].reductions[idx].sliceIndex = parseInt(slider.value);
                    if (sliceValueSpan) sliceValueSpan.textContent = reduceVals[slider.value]?.toFixed(3) || reduceVals[slider.value];
                    if (dimInfo) dimInfo.textContent = `${reduceVals.length} values`;
                }
                
                // Update status text since reduced columns changed
                updateReductionUI(measurementIndex);
                refreshVisualization(measurementIndex);
            });
        }
        
        // Method button clicks
        row.querySelectorAll('.reduction-method-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const idx = parseInt(this.dataset.reductionIndex);
                const method = this.dataset.method;
                
                // Update button states
                row.querySelectorAll('.reduction-method-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                
                // Show/hide slice slider
                const sliderContainer = row.querySelector('.slice-slider-container');
                if (sliderContainer) {
                    sliderContainer.classList.toggle('active', method === 'slice');
                }
                
                vizState[measurementIndex].reductions[idx].method = method;
                refreshVisualization(measurementIndex);
            });
        });
        
        // Slice slider change
        const slider = row.querySelector('.slice-slider');
        if (slider) {
            slider.addEventListener('input', function() {
                const idx = parseInt(this.dataset.reductionIndex);
                const sliceIndex = parseInt(this.value);
                
                vizState[measurementIndex].reductions[idx].sliceIndex = sliceIndex;
                
                const sliceValueSpan = row.querySelector('.slice-value');
                const reduceVals = vizState[measurementIndex].reductions[idx].reduceVals || [];
                if (sliceValueSpan && reduceVals[sliceIndex] !== undefined) {
                    sliceValueSpan.textContent = reduceVals[sliceIndex]?.toFixed(3) || reduceVals[sliceIndex];
                }
                
                refreshVisualization(measurementIndex);
            });
        }
        
        // Remove button click
        const removeBtn = row.querySelector('.remove-reduction-btn');
        if (removeBtn) {
            removeBtn.addEventListener('click', function() {
                const idx = parseInt(this.dataset.reductionIndex);
                removeReduction(measurementIndex, idx);
            });
        }
    }
    
    // Handle "Add Reduction" button clicks
    document.querySelectorAll('.add-reduction-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const measurementIndex = this.dataset.measurement;
            console.log('Add Reduction clicked for measurement:', measurementIndex);
            addReduction(measurementIndex);
        });
    });
    
    // Handle Z-axis select changes for heatmaps
    document.querySelectorAll('.z-axis-select').forEach(select => {
        select.addEventListener('change', function() {
            const measurementIndex = parseInt(this.dataset.measurement);
            vizState[measurementIndex] = vizState[measurementIndex] || {};
            vizState[measurementIndex].zCol = this.value;
            // Update reduction UI since Z-axis is now a protected column
            updateReductionUI(measurementIndex);
            refreshVisualization(measurementIndex);
        });
    });
    
    // Handle legend select changes for line/scatter plots
    document.querySelectorAll('.legend-select').forEach(select => {
        select.addEventListener('change', function() {
            const measurementIndex = parseInt(this.dataset.measurement);
            const legendCol = this.value;
            const chartId = `chart-${measurementIndex}`;
            const chartInfo = charts[chartId];
            
            vizState[measurementIndex] = vizState[measurementIndex] || {};
            vizState[measurementIndex].legendCol = legendCol || null;
            
            // Calculate unique count for the legend column
            if (legendCol && chartInfo) {
                const allValues = chartInfo.data.all_values || [];
                const uniqueValues = [...new Set(allValues.map(r => r[legendCol]))];
                vizState[measurementIndex].legendUniqueCount = uniqueValues.length;
            } else {
                vizState[measurementIndex].legendUniqueCount = 0;
            }
            
            // Update colorscale visibility based on unique count
            const section = this.closest('.measurement-section');
            const legendColorscaleGroup = section.querySelector(`.legend-colorscale-group[data-measurement="${measurementIndex}"]`);
            if (legendColorscaleGroup) {
                const uniqueCount = vizState[measurementIndex].legendUniqueCount || 0;
                legendColorscaleGroup.style.display = (legendCol && uniqueCount >= 10) ? 'flex' : 'none';
            }
            
            // Update reduction UI since legend column is now protected
            updateReductionUI(measurementIndex);
            refreshVisualization(measurementIndex);
        });
    });
    
    // Handle legend colorscale changes for line/scatter plots
    document.querySelectorAll('.legend-colorscale-select').forEach(select => {
        select.addEventListener('change', function() {
            const measurementIndex = parseInt(this.dataset.measurement);
            vizState[measurementIndex] = vizState[measurementIndex] || {};
            vizState[measurementIndex].legendColorscale = this.value;
            refreshVisualization(measurementIndex);
        });
    });
    
    // Initialize vizState for measurements with columns > 2 (start with NO reductions)
    // and update the reduction UI to show initial state
    let initIndex = 1;
    for (const [name, data] of Object.entries(visualizationData)) {
        if (data.data_points && data.data_points.length > 0 && data.columns && data.columns.length > 2) {
            vizState[initIndex] = vizState[initIndex] || {};
            vizState[initIndex].reductions = []; // Start with no reductions
            // Initialize zCol for heatmaps
            const xCol = data.x_column;
            const yCol = data.y_column;
            vizState[initIndex].zCol = data.columns.find(c => c !== xCol && c !== yCol);
            // Update UI after a small delay to ensure charts are created
            setTimeout(() => updateReductionUI(initIndex), 100);
        }
        initIndex++;
    }
    
    // ===== END DIMENSION REDUCTION =====
    
    // Handle measurement tabs
    document.querySelectorAll('.measurement-tab').forEach(tab => {
        tab.addEventListener('click', function() {
            document.querySelectorAll('.measurement-tab').forEach(t => t.classList.remove('active'));
            this.classList.add('active');
            
            const targetId = this.dataset.target;
            document.querySelectorAll('.measurement-section').forEach(s => s.classList.remove('active'));
            document.getElementById(targetId).classList.add('active');
            
            // Trigger chart/heatmap resize
            const index = targetId.split('-')[1];
            const chartId = `chart-${index}`;
            const heatmapId = `heatmap-${index}`;
            
            if (charts[chartId]) charts[chartId].chart.resize();
            if (heatmaps[heatmapId]) {
                const container = document.getElementById(heatmapId);
                if (container) Plotly.Plots.resize(container);
            }
        });
    });
    
    // Copy button functionality
    document.querySelectorAll('.copy-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const text = this.dataset.copy;
            navigator.clipboard.writeText(text).then(() => {
                const originalText = this.textContent;
                this.textContent = 'Copied!';
                setTimeout(() => this.textContent = originalText, 2000);
            });
        });
    });
    
    // ===== SAVE VISUALIZATION TO SAMPLE =====
    // SVG icons for button states
    const savingIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round" class="icon-spin">
        <path d="M8 3V1M8 15v-2M3 8H1M15 8h-2"/>
        <path d="M4.93 4.93L3.51 3.51M12.49 12.49l-1.42-1.42M4.93 11.07l-1.42 1.42M12.49 3.51l-1.42 1.42" opacity="0.5"/>
    </svg>`;
    
    document.querySelectorAll('.save-to-sample-btn').forEach(btn => {
        btn.addEventListener('click', async function() {
            const measurementIndex = this.dataset.measurement;
            const measurementName = this.dataset.measurementName;
            const sampleId = this.dataset.sampleId;
            const sampleName = this.dataset.sampleName;
            const scanName = this.dataset.scanName;
            
            // Disable button during save
            this.disabled = true;
            const originalContent = this.innerHTML;
            this.innerHTML = savingIcon;
            this.title = 'Saving...';
            
            try {
                // Determine if we're showing heatmap or chart
                // Handle "global" button by finding active measurement section
                let section;
                let actualMeasurementIndex = measurementIndex;
                
                if (measurementIndex === 'global') {
                    // Find the currently active measurement section
                    section = document.querySelector('.measurement-section.active');
                    if (!section) {
                        // If no active section, try to get the first one
                        section = document.querySelector('.measurement-section');
                    }
                    // Extract the measurement index from the section id
                    if (section && section.id) {
                        actualMeasurementIndex = section.id.replace('measurement-', '');
                    }
                } else {
                    section = document.getElementById(`measurement-${measurementIndex}`);
                }
                
                if (!section) {
                    throw new Error('No visualization section found');
                }
                const chartWrapper = section.querySelector('.chart-wrapper');
                // Check if heatmap is displayed by checking the heatmap-view element's display style
                const heatmapView = chartWrapper ? chartWrapper.querySelector('.heatmap-view') : null;
                const isHeatmap = heatmapView && (heatmapView.style.display === 'block' || getComputedStyle(heatmapView).display !== 'none');
                
                let imageData;
                const chartId = `chart-${actualMeasurementIndex}`;
                const heatmapId = `heatmap-${actualMeasurementIndex}`;
                
                if (isHeatmap && heatmaps[heatmapId]) {
                    // Capture Plotly heatmap - wait for any pending renders
                    const heatmapContainer = document.getElementById(heatmapId);
                    
                    // Force Plotly to complete any pending updates and set white background for export
                    await Plotly.relayout(heatmapContainer, {
                        paper_bgcolor: 'white',
                        plot_bgcolor: 'white'
                    });
                    
                    // Small delay to ensure render completes
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    imageData = await Plotly.toImage(heatmapContainer, {
                        format: 'png',
                        width: 1200,
                        height: 800,
                        scale: 2
                    });
                } else if (charts[chartId] && charts[chartId].chart) {
                    // Capture Chart.js canvas
                    const canvas = document.getElementById(chartId);
                    
                    // Create a temporary canvas with white background
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width * 2;
                    tempCanvas.height = canvas.height * 2;
                    const ctx = tempCanvas.getContext('2d');
                    
                    // Fill white background
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    
                    // Scale and draw the chart
                    ctx.scale(2, 2);
                    ctx.drawImage(canvas, 0, 0);
                    
                    imageData = tempCanvas.toDataURL('image/png');
                } else {
                    throw new Error('No visualization found to capture');
                }
                
                // Get current visualization type
                const vizTypeSelect = section.querySelector('.viz-type-select');
                const vizType = vizTypeSelect ? vizTypeSelect.value : 'chart';
                
                // Get axis info
                const xSelect = section.querySelector('.x-axis-select');
                const ySelect = section.querySelector('.y-axis-select');
                const xAxis = xSelect ? xSelect.value : '';
                const yAxis = ySelect ? ySelect.value : '';
                
                // Create description
                const description = `${vizType.charAt(0).toUpperCase() + vizType.slice(1)} visualization from scan "${scanName}"\nMeasurement: ${measurementName}\nX-Axis: ${xAxis}\nY-Axis: ${yAxis}`;
                const imageName = `${scanName} - ${measurementName} (${vizType})`;
                
                // Upload to sample
                const response = await fetch(`/api/images/sample/${sampleId}/upload-base64`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify({
                        image_data: imageData,
                        name: imageName,
                        description: description
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Show success using PyBirchModal if available, otherwise alert
                    if (typeof PyBirchModal !== 'undefined') {
                        await PyBirchModal.alert({
                            type: 'success',
                            title: 'Saved to Sample',
                            body: `<p>Visualization saved to <strong>${sampleName}</strong></p>
                                   <div class="info-text">
                                       <a href="/samples/${sampleId}#images" target="_blank">View in sample gallery ‚Üí</a>
                                   </div>`
                        });
                    } else {
                        alert(`Visualization saved to ${sampleName}!`);
                    }
                } else {
                    throw new Error(result.error || 'Failed to save image');
                }
            } catch (error) {
                console.error('Save to sample error:', error);
                if (typeof PyBirchModal !== 'undefined') {
                    await PyBirchModal.alert({
                        type: 'danger',
                        title: 'Error',
                        body: `<p>Failed to save visualization: ${error.message}</p>`
                    });
                } else {
                    alert('Failed to save visualization: ' + error.message);
                }
            } finally {
                this.disabled = false;
                this.innerHTML = originalContent;
                this.title = `Save visualization to ${sampleName}`;
            }
        });
    });
    
    // ===== REAL-TIME UPDATES =====
    // Include scan-realtime.js and initialize
</script>
<script src="{{ url_for('static', filename='js/scan-realtime.js') }}"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize scan realtime manager
        const scanId = '{{ scan.scan_id or scan.id }}';
        window.scanManager = new ScanRealtimeManager(scanId);
        
        // Set up log panel
        const logPanel = document.getElementById('scan-log-panel');
        if (logPanel) {
            window.scanManager.setLogContainer(logPanel);
        }
        
        // Clear log button handler
        const clearLogBtn = document.getElementById('clear-scan-log-btn');
        if (clearLogBtn) {
            clearLogBtn.addEventListener('click', function() {
                if (logPanel) {
                    logPanel.innerHTML = '<div class="log-entry INFO"><span class="log-timestamp">--:--:--</span> Log cleared</div>';
                }
            });
        }
        
        {% if scan.status == 'running' %}
        // For running scans, set up live chart
        // Using existing chart infrastructure from page
        console.log('Scan is running - real-time updates enabled');
        {% endif %}
    });
</script>
{% endblock %}
