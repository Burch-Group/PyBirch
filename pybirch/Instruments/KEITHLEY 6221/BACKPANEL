import sys
import re
import os
import time
from typing import Any, Dict, Union, Callable, Optional, Tuple
import math
import json
import threading
import queue
import pyvisa
#from pymeasure.instruments.keithley import Keithley6221
from typing import Optional, List, Dict, Any, Callable
#import simpleaudio
import time
import threading
from PyQt5.QtCore import Qt, pyqtSignal, QObject, QTimer, QThread, pyqtSlot
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLabel, QPushButton, QComboBox, QGroupBox, QDoubleSpinBox, QSpinBox,
    QPlainTextEdit, QLineEdit, QFileDialog, QMessageBox, QCheckBox,
    QTabWidget, QProgressBar, QTextEdit
)
import pyvisa
from pyvisa.resources import MessageBasedResource
from dataclasses import dataclass
from typing import Callable, Optional, Any, Iterable

@dataclass
class SettingSpec:
    key: str                      # e.g. "source.current.level"
    scpi_set: str                 # e.g. "SOUR:CURR:LEV {value}"
    scpi_get: Optional[str] = None
    validator: Optional[Callable[[Any], bool]] = None
    transform: Optional[Callable[[Any], Any]] = None
    default: Any = None
    widget: Any = None
    unit_widget: Any = None

def float_setting(
    key: str,
    scpi: str,
    *,
    min: float | None = None,
    max: float | None = None,
    default: float | None = None,
) -> SettingSpec:
    def validator(v):
        if min is not None and v < min: return False
        if max is not None and v > max: return False
        return True

    return SettingSpec(
        key=key,
        scpi_set=f"{scpi} {{value}}",
        scpi_get=f"{scpi}?",
        validator=validator,
        default=default,
    )


def bool_setting(key: str, scpi: str, *, default: bool | None = None) -> SettingSpec:
    return SettingSpec(
        key=key,
        scpi_set=f"{scpi} {{value}}",
        scpi_get=f"{scpi}?",
        transform=lambda v: "ON" if bool(v) else "OFF",
        default=default,
    )

def enum_setting(key: str, scpi: str, allowed: Iterable[str], *, default: str | None = None) -> SettingSpec:
    allowed = set(allowed)

    def validator(v):
        return True if not allowed else (v in allowed)   # ✅ allow anything when allowed is empty

    return SettingSpec(
        key=key,
        scpi_set=f"{scpi} {{value}}",
        scpi_get=f"{scpi}?",
        validator=validator,
        default=default,
    )

def build_all_settings() -> Iterable[SettingSpec]:
    # keep your existing explicit groups if you want
    yield from source_current_settings()
    yield from source_compliance_settings()
    yield from source_output_settings()

    # automatically pull in everything else from command_map
    yield from build_all_settings_from_command_map(command_map)

def to_nested(flat: dict[str, Any]) -> dict:
    root: dict = {}
    for k, v in flat.items():
        parts = k.split(".")
        cur = root
        for p in parts[:-1]:
            cur = cur.setdefault(p, {})
        cur[parts[-1]] = v
    return root


def build_setting_registry() -> dict[str, SettingSpec]:
    """
    Auto-build registry from generators.
    YOU NEVER EDIT THIS MANUALLY.
    """
    registry = {}
    for spec in build_all_settings():
        if spec.key in registry:
            raise KeyError(f"Duplicate setting key: {spec.key}")
        registry[spec.key] = spec
    return registry
from typing import Callable, Any

def build_callable_settings(driver: "FullDriver", registry: dict[str, SettingSpec]) -> dict[str, Callable[[Any], None]]:
    callables: dict[str, Callable[[Any], None]] = {}

    for key, spec in registry.items():
        def _make_setter(spec: SettingSpec):
            def _setter(value: Any) -> None:
                v = value
                if spec.transform:
                    v = spec.transform(v)
                if spec.validator and not spec.validator(v):
                    raise ValueError(f"Validation failed for {spec.key}: {value}")
                cmd = spec.scpi_set.format(value=v)
                driver.queue(cmd)
            return _setter

        callables[key] = _make_setter(spec)

    return callables

def build_default_settings(registry: dict[str, SettingSpec]) -> dict[str, Any]:
    return {key: spec.default for key, spec in registry.items()}


def apply_settings_dict(driver, values: dict[str, Any], registry: dict[str, SettingSpec]):
    """
    Apply settings without ANY UI present.
    This is the ONLY path from values -> SCPI.
    """
    for key, value in values.items():
        if key not in registry:
            raise KeyError(f"Unknown setting: {key}")

        spec = registry[key]

        if spec.transform:
            value = spec.transform(value)

        if spec.validator and not spec.validator(value):
            raise ValueError(f"Validation failed for {key}: {value}")

        cmd = spec.scpi_set.format(value=value)
        driver.queue(cmd)


def source_current_settings():
    base = "source.current"
    scpi = "SOUR:CURR"

    yield float_setting(
        key=f"{base}.level",
        scpi=f"{scpi}:LEV",
        min=1e-12,
        max=0.105,
        default=1e-3,          # example default: 1 mA
    )

    yield bool_setting(
        key=f"{base}.autorange",
        scpi=f"{scpi}:RANG:AUTO",
        default=True,
    )

    yield float_setting(
        key=f"{base}.range",
        scpi=f"{scpi}:RANG",
        min=1e-12,
        max=0.105,
        default=0.01,          # example default: 10 mA range
    )


def source_compliance_settings():
    base = "source.compliance"
    scpi = "SOUR:VOLT"

    yield float_setting(
        key=f"{base}.voltage",
        scpi=f"{scpi}:PROT",
        min=0.01,
        max=105.0,
        default=10.0,
    )


def source_output_settings():
    base = "source.output"
    scpi = "OUTP"

    yield bool_setting(
        key=f"{base}.enabled",
        scpi=scpi,
        default=False,
    )

MAX_CURRENT_A = 0.105
MIN_CURRENT_A = 1e-13
MAX_COMPLIANCE_V = 105.0
MIN_COMPLIANCE_V = 0.1

def _fmt(val: float) -> str:
    return f"{val:.12g}"

def _to_amps(value: float, unit: str) -> float:
    u = unit.lower()
    if u in ("a","amp","amps"): return value
    if u in ("ma","milli","milliamps"): return value * 1e-3
    if u in ("ua","µa","micro","microamp","ua"): return value * 1e-6
    if u in ("na","nano","nanoamp"): return value * 1e-9
    if u in ("pa","pico","picoamp"): return value * 1e-12
    return value

# Central SCPI mapping (editable)
command_map = {
    "idn":"*IDN?",
    "reset":"*RST",
    "clear":"*CLS",
    "stb":"*STB?",
    "syst_err":"SYST:ERR?",
    "output_on":"OUTP ON",
    "output_off":"OUTP OFF",
    "output_q":"OUTP?",
    # source
    "sour_func_curr":"SOUR:FUNC CURR",
    "sour_curr_lev":"SOUR:CURR:LEV {val}",
    "sour_curr_start":"SOUR:CURR:START {val}",
    "sour_curr_stop":"SOUR:CURR:STOP {val}",
    "sour_curr_step":"SOUR:CURR:STEP {val}",
    "sour_curr_dwell":"SOUR:CURR:DWELL {val}",
    "sour_curr_rang":"SOUR:CURR:RANG {val}",
    "sour_curr_rang_auto":"SOUR:CURR:RANG:AUTO {onoff}",
    "sour_curr_pol":"SOUR:CURR:POL {pol}",
    "sour_volt_prot":"SOUR:VOLT:PROT {val}",
    # wave
    "sour_wave_mode":"SOUR:FUNC:MODE MULT",
    "sour_wave_func":"SOUR:WAVE:FUNC {type}",
    "sour_wave_ampl":"SOUR:WAVE:AMPL {val}",
    "sour_wave_freq":"SOUR:WAVE:FREQ {val}",
    "sour_wave_offs":"SOUR:WAVE:OFFS {val}",
    "sour_wave_duty":"SOUR:WAVE:DUTY {val}",
    "sour_wave_phas":"SOUR:WAVE:PHAS {val}",
    "sour_wave_burs":"SOUR:WAVE:BURS {onoff}",
    "sour_wave_burs_count":"SOUR:WAVE:BURS:COUNT {val}",
    "sour_wave_phasmk":"SOUR:WAVE:PHAS:MARK {onoff}",
    # trig
    "trig_source":"TRIG:SOUR {src}",
    "trig_delay":"TRIG:DEL {val}",
    "trig_count":"TRIG:COUN {val}",
    "trig_out_puls_wid":"TRIG:OUT:PULS:WID {val}",
    # meas/averaging
    "sens_aver_stat":"SENS:AVER:STAT {onoff}",
    "sens_aver_count":"SENS:AVER:COUNT {val}",
    "sens_range_volt":"SENS:VOLT:RANG {val}",
    "sens_range_curr":"SENS:CURR:RANG {val}",
    "format_ascii":"FORM:DATA ASCII",
    # trace
    "trac_cle":"TRAC:CLE",
    "trac_poin":"TRAC:POIN {n}",
    "trac_feed":"TRAC:FEED {feed}",
    "trac_feed_sour":"TRAC:FEED:SOUR \"{src}\"",
    # memory
    "setup_write":"SYST:SETup:WRIte {slot}",
    "setup_read":"SYST:SETup:READ {slot}",
    "setup_power":"SYST:SET:POWER {slot}",
    "panel_lock":"SYST:LOCK {onoff}",
    # diag
    "self_test":"*TST?",
    "diag":"SYST:DIAG?"
}

_PLACEHOLDER_RE = re.compile(r"\{(\w+)\}")

def _cmd_placeholders(cmd: str) -> set[str]:
    return set(_PLACEHOLDER_RE.findall(cmd))

def _looks_like_query(cmd: str) -> bool:
    return cmd.strip().endswith("?")

def _is_setting_cmd(cmd: str) -> bool:
    """
    We treat commands with placeholders (val/onoff/etc) as settings.
    Queries/actions like *TST?, SYST:ERR?, TRAC:CLE are not settings.
    """
    if _looks_like_query(cmd):
        return False
    return len(_cmd_placeholders(cmd)) > 0

def _key_from_command_map_name(name: str) -> str:
    """
    Map command_map keys -> dotted setting keys.
    Example: sour_wave_freq -> source.wave.frequency
    """
    parts = name.split("_")

    # rough grouping
    if parts[0] == "sour":
        group = "source"
        rest = parts[1:]
    elif parts[0] == "trig":
        group = "trigger"
        rest = parts[1:]
    elif parts[0] == "sens":
        group = "sense"
        rest = parts[1:]
    elif parts[0] == "trac":
        group = "trace"
        rest = parts[1:]
    elif parts[0] in ("setup", "panel"):
        group = "system"
        rest = parts
    else:
        group = "system"
        rest = parts

    # normalize common tokens
    token_map = {
        "lev": "level",
        "rang": "range",
        "freq": "frequency",
        "ampl": "amplitude",
        "offs": "offset",
        "phas": "phase",
        "duty": "duty",
        "burs": "burst.enabled",
        "count": "count",
        "pol": "polarity",
        "wid": "width",
        "stat": "enabled",
        "poin": "points",
        "feed": "feed",
        "mode": "mode",
        "sour": "source",
        "prot": "protection",
        "write": "write",
        "read": "read",
        "power": "power",
        "lock": "lock",
        "gpib": "gpib",
        "addr": "address",
    }

    # expand tokens
    out = []
    for t in rest:
        out.append(token_map.get(t, t))

    # if we embedded a dotted token like "burst.enabled", split it
    dotted = []
    for t in out:
        dotted.extend(t.split("."))

    return ".".join([group] + dotted)

def build_all_settings_from_command_map(cmd_map: dict[str, str]) -> Iterable[SettingSpec]:
    """
    Auto-generate SettingSpec from command_map entries.
    Defaults here are conservative; you can refine later.
    """
    for name, cmd in cmd_map.items():
        if not _is_setting_cmd(cmd):
            continue

        placeholders = _cmd_placeholders(cmd)
        key = _key_from_command_map_name(name)

        # choose a builder based on placeholder type
        if "onoff" in placeholders:
            yield bool_setting(key=key, scpi=cmd.replace(" {onoff}", ""), default=False)
        elif "val" in placeholders or "n" in placeholders or "slot" in placeholders:
            # numeric setting; default None unless you want to pick specific defaults
            scpi = cmd.split("{")[0].strip()
            yield float_setting(key=key, scpi=scpi, default=None)
        else:
            # string/enum-ish setting (pol, type, src, feed, etc.)
            scpi = cmd.split("{")[0].strip()
            # allow unknown values by not validating yet
            yield enum_setting(key=key, scpi=scpi, allowed=set(), default=None)

class DriverSignals(QObject):
    cmd_result = pyqtSignal(str, object)
    cmd_error = pyqtSignal(str, str)
    log = pyqtSignal(str)

class FullDriver(QObject):
    def __init__(self, visa_backend: Optional[str] = None, timeout_ms: int = 5000):
        super().__init__()
        self.signals = DriverSignals()
        try:
            self.rm = pyvisa.ResourceManager(visa_backend) if visa_backend else pyvisa.ResourceManager()
        except Exception as e:
            self.rm = None
            self.signals.log.emit(f"VISA init failed: {e}")
        self.inst: Optional[MessageBasedResource] = None
        self._lock = threading.RLock()
        self.timeout_ms = int(timeout_ms)
        self._queue: "queue.Queue[tuple]" = queue.Queue()
        self._stop = threading.Event()
        self._worker: Optional[threading.Thread] = None
        self.write_termination = "\n"
        self.read_termination = "\n"
        self.eoi = True
        self.registry = build_setting_registry()
        self.DEFAULT_SETTINGS = build_default_settings(self.registry)
        self.CALLABLE_SETTINGS = self.build_callable_settings( self.registry)

        print("DEFAULT SETTINGS:")
        print(self.DEFAULT_SETTINGS)

        print("CALLABLE SETTINGS:")
        print({k: v for k, v in self.CALLABLE_SETTINGS.items()})

    def apply_settings_dict(self, settings: dict, registry: dict[str, SettingSpec]):
        for key, value in settings.items():
            if key not in registry:
                raise KeyError(f"Unknown setting: {key}")

            spec = registry[key]

            if spec.transform:
                value = spec.transform(value)

            if spec.validator and not spec.validator(value):
                raise ValueError(f"Invalid value for {key}: {value}")

            cmd = spec.scpi_set.format(value=_fmt(value))
            self.queue(cmd)
    def query_timeout(self, cmd: str, timeout_ms: int) -> str:
        with self._lock:
            if not self.inst:
                raise ConnectionError("Not connected")
            old = self.inst.timeout
            try:
                self.inst.timeout = int(timeout_ms)
                return str(self.inst.query(cmd)).strip()
            finally:
                self.inst.timeout = old

    def apply_settings(self, settings: dict) -> tuple[bool, str]:
        """
        Apply settings from a dictionary without UI interaction.
        
        Args:
            settings: Dictionary containing instrument settings
            
        Returns:
            tuple: (success: bool, message: str)
        """
        try:
            # Validate settings first
            is_valid, message = self.validate_settings(settings)
            if not is_valid:
                return False, f"Invalid settings: {message}"

            # Source settings
            if 'source' in settings:
                src = settings['source']
                if 'level' in src:
                    self.queue(f"SOUR:CURR:LEV {src['level']}")
                if 'compliance' in src:
                    self.queue(f"SOUR:CURR:COMP {src['compliance']}")
                if 'output_enabled' in src:
                    self.queue(f"OUTP {'ON' if src['output_enabled'] else 'OFF'}")
                if 'mode' in src:
                    self.queue(f"SOUR:FUNC:MODE {src['mode']}")
                if 'function' in src:
                    self.queue(f"SOUR:FUNC {src['function']}")
                if 'autorange' in src:
                    self.queue(f"SOUR:CURR:RANG:AUTO {1 if src['autorange'] else 0}")
                if 'range' in src and 'autorange' in src and not src['autorange']:
                    self.queue(f"SOUR:CURR:RANG {src['range']}")
                if 'delay' in src:
                    self.queue(f"SOUR:DEL {src[ 'delay']}")
                if 'filter' in src:
                    filt = src['filter']
                    if 'enabled' in filt:
                        self.queue(f"SOUR:CURR:FILT:STAT {1 if filt['enabled'] else 0}")
                    if 'type' in filt:
                        self.queue(f"SOUR:CURR:FILT:TCON {filt['type']}")
                    if 'count' in filt:
                        self.queue(f"SOUR:CURR:FILT:COUN {filt['count']}")
            
            # Waveform settings
            if 'waveform' in settings:
                wave = settings['waveform']
                if 'type' in wave:
                    self.queue(f"SOUR:WAVE:FUNC {wave['type']}")
                if 'amplitude' in wave:
                    self.queue(f"SOUR:WAVE:AMPL {wave['amplitude']}")
                if 'frequency' in wave:
                    self.queue(f"SOUR:WAVE:FREQ {wave['frequency']}")
                if 'offset' in wave:
                    self.queue(f"SOUR:WAVE:OFFS {wave['offset']}")
                if 'duty_cycle' in wave and wave['type'] in ['SQUARE', 'PULSE']:
                    self.queue(f"SOUR:WAVE:DCYC {wave['duty_cycle']}")
                if 'symmetry' in wave and wave['type'] == 'TRIANGLE':
                    self.queue(f"SOUR:WAVE:SYMM {wave['symmetry']}")
                if 'phase' in wave:
                    self.queue(f"SOUR:WAVE:PHAS {wave['phase']}")
                if 'burst' in wave:
                    burst = wave['burst']
                    if 'enabled' in burst:
                        self.queue(f"SOUR:WAVE:BURS:STAT {1 if burst['enabled'] else 0}")
                    if 'count' in burst:
                        self.queue(f"SOUR:WAVE:BURS:NCYC {burst['count']}")
                    if 'mode' in burst:
                        self.queue(f"SOUR:WAVE:BURS:MODE {burst['mode']}")
                    if 'polarity' in burst:
                        self.queue(f"SOUR:WAVE:BURS:POL {burst['polarity']}")
            
            # Add more settings groups as needed (trigger, sweep, measurement, etc.)
            
            return True, "Settings applied successfully"
            
        except Exception as e:
            return False, f"Error applying settings: {str(e)}"

    def get_current_settings(self) -> dict:
        """
        Get current instrument settings as a dictionary.
        
        Returns:
            dict: Current settings
        """
        settings = {}
        try:
            # Source settings
            settings['source'] = {
                'level': float(self.query("SOUR:CURR:LEV?")),
                'compliance': float(self.query("SOUR:CURR:COMP?")),
                'output_enabled': bool(int(self.query("OUTP?"))),
                'mode': self.query("SOUR:FUNC:MODE?").strip(),
                'function': self.query("SOUR:FUNC?").strip(),
                'autorange': bool(int(self.query("SOUR:CURR:RANG:AUTO?"))),
                'range': float(self.query("SOUR:CURR:RANG?")),
                'delay': float(self.query("SOUR:DEL?")),
                'filter': {
                    'enabled': bool(int(self.query("SOUR:CURR:FILT:STAT?"))),
                    'type': self.query("SOUR:CURR:FILT:TCON?").strip(),
                    'count': int(self.query("SOUR:CURR:FILT:COUN?"))
                }
            }
            
            # Waveform settings
            settings['waveform'] = {
                'type': self.query("SOUR:WAVE:FUNC?").strip('"'),
                'amplitude': float(self.query("SOUR:WAVE:AMPL?")),
                'frequency': float(self.query("SOUR:WAVE:FREQ?")),
                'offset': float(self.query("SOUR:WAVE:OFFS?")),
                'duty_cycle': float(self.query("SOUR:WAVE:DCYC?")),
                'symmetry': float(self.query("SOUR:WAVE:SYMM?")),
                'phase': float(self.query("SOUR:WAVE:PHAS?")),
                'burst': {
                    'enabled': bool(int(self.query("SOUR:WAVE:BURS:STAT?"))),
                    'count': int(float(self.query("SOUR:WAVE:BURS:NCYC?"))),
                    'mode': self.query("SOUR:WAVE:BURS:MODE?").strip(),
                    'polarity': self.query("SOUR:WAVE:BURS:POL?").strip()
                }
            }
            
            # Add more settings groups as needed
            
        except Exception as e:
            self.signals.log.emit(f"Error getting settings: {str(e)}")
            raise
        
        return settings

    def validate_settings(self, settings: dict) -> tuple[bool, str]:
        """
        Validate settings before applying.
        
        Args:
            settings: Dictionary containing settings to validate
            
        Returns:
            tuple: (is_valid: bool, message: str)
        """
        try:
            if 'source' in settings:
                src = settings['source']
                if 'level' in src and not (MIN_CURRENT_A <= abs(src['level']) <= MAX_CURRENT_A):
                    return False, f"Current level must be between {MIN_CURRENT_A} and {MAX_CURRENT_A} A"
                if 'compliance' in src and not (MIN_COMPLIANCE_V <= src['compliance'] <= MAX_COMPLIANCE_V):
                    return False, f"Compliance must be between {MIN_COMPLIANCE_V} and {MAX_COMPLIANCE_V} V"
                if 'range' in src and not (MIN_CURRENT_A <= abs(src['range']) <= MAX_CURRENT_A):
                    return False, f"Range must be between {MIN_CURRENT_A} and {MAX_CURRENT_A} A"
                
                if 'filter' in src:
                    filt = src['filter']
                    if 'count' in filt and (filt['count'] < 1 or filt['count'] > 100):
                        return False, "Filter count must be between 1 and 100"
            
            if 'waveform' in settings:
                wave = settings['waveform']
                if 'amplitude' in wave and not (0 <= wave['amplitude'] <= MAX_CURRENT_A):
                    return False, f"Amplitude must be between 0 and {MAX_CURRENT_A} A"
                if 'frequency' in wave and (wave['frequency'] < 0 or wave['frequency'] > 1e6):
                    return False, "Frequency must be between 0 and 1 MHz"
                if 'offset' in wave and not (-MAX_CURRENT_A <= wave['offset'] <= MAX_CURRENT_A):
                    return False, f"Offset must be between {-MAX_CURRENT_A} and {MAX_CURRENT_A} A"
                if 'duty_cycle' in wave and not (0 <= wave['duty_cycle'] <= 100):
                    return False, "Duty cycle must be between 0 and 100%"
                if 'symmetry' in wave and not (0 <= wave['symmetry'] <= 100):
                    return False, "Symmetry must be between 0 and 100%"
                if 'phase' in wave and not (0 <= wave['phase'] <= 360):
                    return False, "Phase must be between 0 and 360 degrees"
                
                if 'burst' in wave:
                    burst = wave['burst']
                    if 'count' in burst and (burst['count'] < 1 or burst['count'] > 1e6):
                        return False, "Burst count must be between 1 and 1,000,000"
            
            # Add more validation as needed
            
            return True, "Settings are valid"
            
        except Exception as e:
            return False, f"Validation error: {str(e)}"
# Insert into FullDriver
    def build_callable_settings(self, registry: dict[str, SettingSpec]) -> dict[str, Callable]:
        """
        Auto-generate setting -> function map from SCPI templates.
        """
        callables = {}

        for key, spec in registry.items():
            before, after, has_value = self.split_command(spec.scpi_set)

            if has_value:
                def make_fn(b=before, a=after):
                    return lambda v: self.queue(f"{b}{_fmt(v)}{a}")
                callables[key] = make_fn()
            else:
                callables[key] = lambda _=None, b=before: self.queue(b)

        return callables

    def query_options_and_firmware(self):
        result = {"idn": "", "vers": "", "options": []}
        try:
            result["idn"] = self.query("*IDN?")
        except Exception:
            pass
        # some firmwares expose SYST:OPT? or SYST:VERS?; try both
        try:
            vers = self.query("SYST:VERS?")
            result["vers"] = vers
        except Exception:
            pass
        # try known option query token (firmware-dependent)
        try:
            opts = self.query("SYST:OPT?")
            # parse comma-separated option list if present
            result["options"] = [o.strip() for o in str(opts).split(",") if o.strip()]
        except Exception:
            pass
        self.signals.log.emit(f"Options detection: {result}")
        return result
# Insert into FullDriver

    def stream_trace_to_file_resilient(self, outfile: str, buffer_name: str = "defbuffer1", chunk_size: int = 1000, interval_s: float = 1.0, circular: bool = False, stop_event: threading.Event = None, reconnect_attempts:int=3):
        def _stream():
            self.signals.log.emit(f"Starting resilient stream to {outfile}")
            with open(outfile, "ab") as fh:
                offset = 1
                attempts = 0
                while stop_event is None or not stop_event.is_set():
                    try:
                        raw = self.query(f"TRAC:DATA? {offset},{offset+chunk_size-1},\"{buffer_name}\"")
                        fh.write((raw + "\n").encode('utf-8'))
                        fh.flush()
                        offset += chunk_size
                        attempts = 0
                        time.sleep(interval_s)
                        if circular:
                            offset = 1
                    except Exception as e:
                        attempts += 1
                        self.signals.log.emit(f"Stream read error (attempt {attempts}): {e}")
                        if attempts > reconnect_attempts:
                            self.signals.log.emit("Reconnection attempts exhausted; stopping stream")
                            break
                        time.sleep(1.0)
            self.signals.log.emit("Resilient trace stream stopped")
        tstop = stop_event or threading.Event()
        th = threading.Thread(target=_stream, daemon=True)
        th.start()
        return tstop

    def set_trigger_matrix(self, matrix: dict):
        """
        matrix: dict of {output_name: {'route': target, 'polarity': 'POS'|'NEG', 'threshold_v': float}}
        Example: {"TRIGOUT1": {"route":"SAMPLE","polarity":"POS","threshold_v":3.3}}
        This function composes commands per instrument syntax. Adjust tokens for firmware.
        """
        for out, spec in matrix.items():
            # example command pattern (firmware-specific): TRIG:OUT<n>:ROUTe <target>
            try:
                route_cmd = f"TRIG:{out}:ROUT {spec['route']}"
                self.queue(route_cmd)
                if 'polarity' in spec:
                    self.queue(f"TRIG:{out}:POL {spec['polarity']}")
                if 'threshold_v' in spec:
                    self.queue(f"TRIG:{out}:THR {float(spec['threshold_v'])}")
                self.signals.log.emit(f"Set trigger {out} -> {spec}")
            except Exception as e:
                self.signals.log.emit(f"Trigger matrix set error for {out}: {e}")

    # Core resource methods
    def list_resources(self) -> List[str]:
        if not self.rm: return []
        try:
            return list(self.rm.list_resources())
        except Exception as e:
            self.signals.log.emit(f"list_resources failed: {e}")
            return []

    def f_that_makes_no_sense(self, item: Union[str, Dict[str, Any]]) -> Union[Callable, Dict[str, Any]]:
        if isinstance(item, dict):
            return {key: self.f_that_makes_no_sense(value) for key, value in item.items()}
        return self.generate_function(item)

    def split_command(self, cmd: str) -> Tuple[str, str, bool]:
        """
        Splits a command template into prefix, suffix, and whether it contains a placeholder.
        
        Args:
            cmd: Command template string that may contain {value} placeholder
            
        Returns:
            Tuple of (prefix, suffix, has_placeholder)
            
        Example:
            >>> split_command("SOUR:CURR:LEV {value}")
            ("SOUR:CURR:LEV ", "", True)
        """
        if not isinstance(cmd, str):
            raise ValueError(f"Command must be a string, got {type(cmd)}")
            
        if "{" not in cmd:
            return cmd, "", False
            
        parts = cmd.split("{", 1)
        if len(parts) != 2:
            raise ValueError(f"Malformed command template (unmatched {{): {cmd}")
            
        before = parts[0]
        rest = parts[1]
        
        if "}" not in rest:
            raise ValueError(f"Malformed command template (unmatched }}): {cmd}")
            
        middle_rest = rest.split("}", 1)
        if len(middle_rest) != 2:
            raise ValueError(f"Malformed command template (extra }}): {cmd}")
            
        after = middle_rest[1]
        
        # Verify the placeholder is exactly {value}
        placeholder = middle_rest[0]
        if placeholder.strip() != "value":
            raise ValueError(f"Only {{value}} placeholder is supported, got {{{placeholder}}}")
            
        return before, after, True

    def generate_function(self, cmd: str) -> Callable[[Any], None]:
        """
        Generates a function that will queue a formatted command when called.
        
        Args:
            cmd: Command template string with optional {value} placeholder
            
        Returns:
            A function that takes a value and queues the formatted command
        """
        try:
            before, after, takes_input = self.split_command(cmd)
            if takes_input:
                return lambda val: self.queue(f"{before}{val}{after}")
            return lambda _=None: self.queue(before)
        except Exception as e:
            error_msg = f"Failed to generate function for command '{cmd}': {str(e)}"
            self.signals.log.emit(f"ERROR: {error_msg}")
            raise ValueError(error_msg) from e

    def set_settings(self, settings: Dict[str, Any]) -> None:
        """
        Applies a dictionary of settings using the callable functions in CALLABLE_SETTINGS.
        
        Args:
            settings: Dictionary of setting names to values
            
        Raises:
            KeyError: If a setting in the dictionary doesn't exist in CALLABLE_SETTINGS
            ValueError: If there's an error processing a command template
        """
        if not hasattr(self, 'CALLABLE_SETTINGS'):
            raise AttributeError("CALLABLE_SETTINGS not initialized")
            
        for key, value in settings.items():
            if key not in self.CALLABLE_SETTINGS:
                raise KeyError(f"Unknown setting: {key}")
                
            try:
                if value is not None:  # Skip None values to allow partial updates
                    self.CALLABLE_SETTINGS[key](value)
                    self.signals.log.emit(f"Applied setting {key} = {value}")
            except Exception as e:
                error_msg = f"Failed to apply setting {key} = {value}: {str(e)}"
                self.signals.log.emit(f"ERROR: {error_msg}")
                raise ValueError(error_msg) from e

    def connect(self, resource_name: str = "GPIB0::12::INSTR") -> bool:
        if not self.rm:
            raise RuntimeError("VISA ResourceManager not initialized")
        # Open VISA
        self.inst = self.rm.open_resource(resource_name)
        # Sanity check
        idn = str(self.inst.query("*IDN?")).strip()
        self.signals.log.emit(f"Connected to: {idn}")

        # Start worker if not already running
        if not getattr(self, "_worker", None) or not self._worker.is_alive():
            self._stop.clear()
            self._worker = threading.Thread(target=self._worker_loop, daemon=True)
            self._worker.start()

        return True

    def close(self) -> None:
        with self._lock:
            try:
                self._stop.set()
                self._queue.put(("__QUIT__", None))
                if self._worker:
                    self._worker.join(timeout=1.0)
            except Exception:
                pass
            try:
                if self.inst:
                    self.inst.close()
            except Exception:
                pass
            finally:
                self.inst = None
                self.signals.log.emit("Disconnected")

    def is_connected(self) -> bool:
        return self.inst is not None



    # Low-level send/query and queueing
    def send(self, cmd: str) -> None:
        with self._lock:
            if not self.inst:
                raise ConnectionError("Not connected")
            self.inst.write(cmd)

    def query(self, cmd: str) -> str:
        with self._lock:
            if not self.inst:
                raise ConnectionError("Not connected")
            return str(self.inst.query(cmd)).strip()

    def read_raw(self, nbytes:int=-1) -> bytes:
        with self._lock:
            if not self.inst:
                raise ConnectionError("Not connected")
            try:
                if nbytes <= 0:
                    return self.inst.read_raw()
                else:
                    return self.inst.read_bytes(nbytes)
            except Exception as e:
                raise

    def set_terminators(self, read_term:str, write_term:str):
        self.read_termination = read_term
        self.write_termination = write_term
        if self.inst:
            try:
                self.inst.read_termination = read_term
                self.inst.write_termination = write_term
            except Exception:
                pass
        self.signals.log.emit(f"Terminators set R:'{read_term}' W:'{write_term}'")

    def set_eoi(self, enable: bool):
        self.eoi = enable
        if self.inst:
            try:
                # best-effort; pyvisa backends vary
                self.inst.session.set_visa_attribute(pyvisa.constants.VI_ATTR_SEND_END_EN, int(enable))
            except Exception:
                pass
        self.signals.log.emit(f"EOI set to {enable}")

    def set_timeout(self, ms:int):
        self.timeout_ms = int(ms)
        if self.inst:
            try:
                self.inst.timeout = int(ms)
            except Exception:
                pass
        self.signals.log.emit(f"Timeout set to {ms} ms")

    def queue(self, cmd: str):
        if not cmd or not isinstance(cmd, str):
            return
        if self.inst is None:
            # surface the error instead of silently dropping work
            self.signals.cmd_error.emit(cmd, "Not connected")
            return
        self._queue.put((cmd, None))

    def _worker_loop(self):
        while not self._stop.is_set():
            try:
                cmd, _ = self._queue.get(timeout=0.2)
            except queue.Empty:
                continue

            try:
                if cmd == "__QUIT__":
                    self._stop.set()
                    break

                if not isinstance(cmd, str) or not cmd.strip():
                    continue

                if cmd.strip().endswith("?"):
                    try:
                        resp = self.query(cmd)
                        self.signals.cmd_result.emit(cmd, resp)
                    except Exception as e:
                        self.signals.cmd_error.emit(cmd, str(e))
                else:
                    try:
                        self.send(cmd)
                        self.signals.cmd_result.emit(cmd, None)
                    except Exception as e:
                        self.signals.cmd_error.emit(cmd, str(e))

            finally:
                try:
                    self._queue.task_done()
                except Exception:
                    pass


    # Convenience helpers
    def idn(self): return self.query(command_map["idn"])
    def reset(self): self.send(command_map["reset"])
    def clear(self): self.send(command_map["clear"])
    def output_on(self): self.send(command_map["output_on"])
    def output_off(self): self.send(command_map["output_off"])
    def syst_err(self): return self.query(command_map["syst_err"])
    def stb(self): return self.query(command_map["stb"])

    def set_current(self, amps: float):
        self.queue(command_map["sour_func_curr"])
        self.queue(command_map["sour_curr_lev"].format(val=_fmt(amps)))

    def set_compliance(self, volts: float):
        self.queue(command_map["sour_volt_prot"].format(val=_fmt(volts)))

    def set_range(self, rng: str):
        if rng.strip().upper() in ("AUTO","ON"):
            self.queue(command_map["sour_curr_rang_auto"].format(onoff="ON"))
        elif rng.strip().upper() in ("OFF","NONE"):
            self.queue(command_map["sour_curr_rang_auto"].format(onoff="OFF"))
        else:
            self.queue(command_map["sour_curr_rang"].format(val=rng))

    def set_polarity(self, pol: str):
        self.queue(command_map["sour_curr_pol"].format(pol=pol))

    def configure_wave(self, params: dict):
        self.queue(command_map["sour_wave_mode"])
        self.queue(command_map["sour_wave_func"].format(type=params.get("type","SINE")))
        self.queue(command_map["sour_wave_ampl"].format(val=_fmt(params.get("amp",0.0))))
        self.queue(command_map["sour_wave_freq"].format(val=_fmt(params.get("freq",1.0))))
        self.queue(command_map["sour_wave_offs"].format(val=_fmt(params.get("offset",0.0))))
        if "duty" in params: self.queue(command_map["sour_wave_duty"].format(val=_fmt(params["duty"])))
        if "phase" in params: self.queue(command_map["sour_wave_phas"].format(val=_fmt(params["phase"])))
        if params.get("burst_on", False):
            self.queue(command_map["sour_wave_burs"].format(onoff="ON"))
            if "burst_count" in params: self.queue(command_map["sour_wave_burs_count"].format(val=int(params["burst_count"])))
        else:
            self.queue(command_map["sour_wave_burs"].format(onoff="OFF"))
        if params.get("phase_marker", False):
            self.queue(command_map["sour_wave_phasmk"].format(onoff="ON"))
        else:
            self.queue(command_map["sour_wave_phasmk"].format(onoff="OFF"))

    # LIST upload (chunked or single)
    def upload_list(self, vals: List[float], chunked: bool=False, chunk_size:int=1000, progress_cb:Optional[Callable[[int,int],None]]=None):
        total = len(vals)
        if not chunked:
            csv = ",".join(_fmt(v) for v in vals)
            self.queue(command_map["sour_func_curr"])
            # many firmwares use SOUR:LIST:LEV
            self.queue(f"SOUR:LIST:LEV {csv}")
            self.queue("SOUR:CURR:MODE LIST")
            if progress_cb: progress_cb(total, total)
        else:
            self.queue(command_map["sour_func_curr"])
            sent = 0
            while sent < total:
                chunk = vals[sent:sent+chunk_size]
                csv = ",".join(_fmt(v) for v in chunk)
                self.queue(f"SOUR:LIST:LEV {csv}")
                sent += len(chunk)
                if progress_cb: progress_cb(sent, total)
            self.queue("SOUR:CURR:MODE LIST")

    # ---------- New helpers requested ----------
    # Guard and floating output
    def set_guard(self, enable: bool):
        self.queue("SOUR:SAFE:GUARD ON" if enable else "SOUR:SAFE:GUARD OFF")
        self.signals.log.emit(f"Guard {'enabled' if enable else 'disabled'}")

    def set_output_floating(self, floating: bool):
        self.queue("OUTP:FLOAT ON" if floating else "OUTP:FLOAT OFF")
        self.signals.log.emit(f"Output floating set to {floating}")

    # Trace / TRAC configuration
    def configure_trace(self, feed: str = "SENSE", points: int = 1000, source: str = "defbuffer1"):
        self.queue(command_map["trac_feed"].format(feed=feed))
        self.queue(command_map["trac_poin"].format(n=int(points)))
        self.queue(command_map["trac_feed_sour"].format(src=source))
        self.signals.log.emit(f"Trace configured feed={feed} points={points} source={source}")

    def read_trace_ascii(self, start:int=1, stop:int=1000, buffer_name:str="defbuffer1"):
        self.queue(f"TRAC:DATA? {start},{stop},\"{buffer_name}\"")

    # Binary block parse helper (IEEE-488.2)
    def parse_ieee488_binary_block(self, data: bytes) -> bytes:
        if not data or data[0:1] != b'#':
            return data
        try:
            nlen = int(chr(data[1]))
            numbytes = int(data[2:2+nlen].decode('ascii'))
            payload = data[2+nlen:2+nlen+numbytes]
            return payload
        except Exception as e:
            raise ValueError(f"Binary block parse failed: {e}")

    def parse_ieee488_definite_block(self, data: bytes) -> bytes:
        if not data:
            raise ValueError("Empty block")
        if data[0:1] != b'#':
            return data
        try:
            if len(data) < 2:
                raise ValueError("Incomplete header")
            nlen_char = chr(data[1])
            if not nlen_char.isdigit():
                raise ValueError("Invalid length-of-length")
            nlen = int(nlen_char)
            header_len = 2 + nlen
            if len(data) < header_len:
                raise ValueError("Incomplete length digits")
            payload_len = int(data[2:2+nlen].decode("ascii"))
            expected_total = header_len + payload_len
            if len(data) < expected_total:
                raise ValueError(f"Incomplete payload expected {payload_len} bytes got {len(data)-header_len}")
            payload = data[header_len:header_len+payload_len]
            # optional: trailing newline(s) are allowed; ignore extras
            return payload
        except Exception as e:
            raise ValueError(f"IEEE-488.2 parse error: {e}")

    # High-level binary query that tries pyvisa.query_binary_values then falls back to raw read and validated parse
    def query_binary_block_safe(self, cmd: str, datatype='B') -> bytes:
        with self._lock:
            if not self.inst:
                raise ConnectionError("Not connected")
            try:
                # preferred pyvisa helper (returns list/array)
                vals = self.inst.query_binary_values(cmd, datatype=datatype, container=bytes)
                if isinstance(vals, (bytes, bytearray)):
                    return bytes(vals)
                if isinstance(vals, list):
                    return bytes(vals)
            except Exception:
                # fallback to manual raw read then parse definite block
                try:
                    # write then raw read (some backends allow query_binary_values; others do not)
                    self.inst.write(cmd)
                    raw = self.inst.read_raw()
                    if isinstance(raw, (bytes, bytearray)) and raw.startswith(b'#'):
                        return self.parse_ieee488_definite_block(raw)
                    # if not a block, return raw as bytes
                    return raw if isinstance(raw, (bytes,bytearray)) else str(raw).encode('utf-8')
                except Exception as e:
                    raise IOError(f"Binary query failed: {e}")

# TRAC full configuration helper exposing feed mode (CONT or TRIG), feed source and point limits
    def configure_trac_full(self, feed: str = "SENSE", feed_mode: str = "CONT", feed_source: str = "defbuffer1", points: int = 1000):
        # enforce sensible limits (hardware may allow more; GUI should reflect manual limits)
        if points < 1 or points > 1000000:
            raise ValueError("Points out of allowable range")
        # TRAC:FEED <feed> ; TRAC:FEED:MODE <CONT|TRIG> ; TRAC:FEED:SOUR "<src>" ; TRAC:POIN <n>
        self.queue(f"TRAC:FEED {feed}")
        self.queue(f"TRAC:FEED:MODE {feed_mode}")
        self.queue(f"TRAC:FEED:SOUR \"{feed_source}\"")
        self.queue(f"TRAC:POIN {int(points)}")
        self.signals.log.emit(f"TRAC configured feed={feed} mode={feed_mode} source={feed_source} points={points}")

    def query_binary_raw(self, cmd: str) -> bytes:
        with self._lock:
            if not self.inst:
                raise ConnectionError("Not connected")
            self.inst.write(cmd)
            raw = self.inst.read_raw()
            return raw
    def set_setting(self, key: str, value):
        fn = self.CALLABLE_SETTINGS.get(key)
        if fn is None:
            raise KeyError(f"Unknown setting: {key}")
        fn(value)

    def apply_settings_dict(self, values: dict[str, object]):
        for k, v in values.items():
            self.set_setting(k, v)

    def read_ese_sre(self) -> dict:
        ese = None; sre = None
        try:
            ese = int(self.query("SYST:ESE?"))
        except Exception:
            pass
        try:
            sre = int(self.query("SYST:SRE?"))
        except Exception:
            pass
        self.signals.log.emit(f"ESE={ese} SRE={sre}")
        return {"ese": ese, "sre": sre}

    # Read event/status registers: returns tuple (stat_ques, stat_oper, stb)
    def read_status_registers(self) -> dict:
        q = None; o = None; s = None
        try:
            q = self.query("STAT:QUES?")
        except Exception: pass
        try:
            o = self.query("STAT:OPER?")
        except Exception: pass
        try:
            s = self.query("*STB?")
        except Exception: pass
        self.signals.log.emit(f"STAT:QUES={q} STAT:OPER={o} *STB={s}")
        return {"ques": q, "oper": o, "stb": s}

    # Decode event bits into human labels (base mapping; extend with manual bit definitions)
    def decode_event_bits(self, val: int) -> dict:
        # minimal mapping; consult manual for full bit meanings and extend
        mapping = {
            0x0001: "Master summary",
            0x0002: "ESR event",
            0x0004: "Command error",
            0x0008: "Measurement complete",
        }
        flags = {name: bool(val & mask) for mask, name in mapping.items()}
        return {"value": val, "flags": flags}

    # SRQ / event masks
    def set_event_status_enable(self, ese_mask:int):
        self.queue(f"SYST:ESE {int(ese_mask)}")
        self.signals.log.emit(f"ESE set to {ese_mask}")

    def set_service_request_enable(self, sre_mask:int):
        self.queue(f"SYST:SRE {int(sre_mask)}")
        self.signals.log.emit(f"SRE set to {sre_mask}")

    def read_event_registers(self):
        self.queue("STAT:QUES?")
        self.queue("STAT:OPER?")
        self.queue("*STB?")

    # Status byte decode helper
    def decode_status_byte(self, val:int) -> dict:
        return {
            "val": val,
            "message": {
                0: "No pending status",
                1: "Operation complete",
                2: "Questionable status",
                3: "Message available",
            }.get(val & 0x0F, "Other")
        }

    # Trigger routing helper (simple)
    def set_trigger_output_route(self, route_spec: str):
        self.queue(route_spec)
        self.signals.log.emit(f"Trigger route set: {route_spec}")

    # Stream trace to disk
    def stream_trace_to_file(self, outfile: str, buffer_name: str = "defbuffer1", chunk_size: int = 1000, interval_s: float = 1.0, circular: bool = False, stop_event: threading.Event = None):
        def _stream():
            self.signals.log.emit(f"Starting trace stream to {outfile}")
            with open(outfile, "ab") as fh:
                offset = 1
                while stop_event is None or not stop_event.is_set():
                    try:
                        raw = self.query(f"TRAC:DATA? {offset},{offset+chunk_size-1},\"{buffer_name}\"")
                        fh.write((raw + "\n").encode('utf-8'))
                        fh.flush()
                        offset += chunk_size
                        time.sleep(interval_s)
                        if circular:
                            offset = 1
                    except Exception as e:
                        self.signals.log.emit(f"Trace stream error: {e}")
                        break
            self.signals.log.emit("Trace stream stopped")
        tstop = stop_event or threading.Event()
        th = threading.Thread(target=_stream, daemon=True)
        th.start()
        return tstop
    def query_with_visa_override(self, cmd: str, timeout_ms: int | None = None) -> str:
        with self._lock:
            if not self.inst:
                raise ConnectionError("Not connected")
            old_timeout = getattr(self.inst, "timeout", None)
            try:
                if timeout_ms is not None:
                    self.inst.timeout = int(timeout_ms)
                return str(self.inst.query(cmd)).strip()
            finally:
                try:
                    if old_timeout is not None:
                        self.inst.timeout = old_timeout
                except Exception:
                    pass

    # Per-command VISA override best-effort
    def send_with_visa_override(self, cmd: str, timeout_ms: Optional[int] = None, eoi: Optional[bool] = None):
        with self._lock:
            if not self.inst:
                raise ConnectionError("Not connected")
            old_timeout = getattr(self.inst, "timeout", None)
            try:
                if timeout_ms is not None:
                    self.inst.timeout = int(timeout_ms)
                if eoi is not None:
                    try:
                        self.inst.session.set_visa_attribute(pyvisa.constants.VI_ATTR_SEND_END_EN, int(eoi))
                    except Exception:
                        pass
                self.inst.write(cmd)
                self.signals.log.emit(f"Sent (override): {cmd}")
            finally:
                try:
                    if old_timeout is not None:
                        self.inst.timeout = old_timeout
                except Exception:
                    pass

    # Protection/readback
    def read_protection_state(self):
        try:
            ovp = self.query("SOUR:VOLT:PROT?")
        except Exception:
            ovp = None
        try:
            inter = self.query("SYST:INT?")
        except Exception:
            inter = None
        self.signals.log.emit(f"Protection read ovp={ovp} interlock={inter}")
        return {"ovp": ovp, "interlock": inter}

    # Front-panel display write
    def write_display_text(self, line:int, text:str):
        self.queue(f"SYST:DISP:TEXT {line},\"{text}\"")
        self.signals.log.emit(f"Display line {line} -> {text}")

    # GPIB helpers
    def gpib_talk(self, addr:int):
        self.queue(f"SYST:COMM:GPIB:TALK {int(addr)}")
    def gpib_listen(self, addr:int):
        self.queue(f"SYST:COMM:GPIB:LIST {int(addr)}")

    # Error classification
    def classify_syst_err(self, err_str: str) -> dict:
        try:
            code = int(err_str.split(",")[0])
        except Exception:
            code = None
        severity = "ok" if code == 0 else ("fatal" if code is not None and code < -100 else "recoverable")
        return {"code": code, "severity": severity, "text": err_str}

class SweepWorker(QThread):
    progress = pyqtSignal(int)
    log = pyqtSignal(str)
    finished = pyqtSignal(list)
    error = pyqtSignal(str)

    def __init__(self, driver: FullDriver, seq: List[float], dwell: float, measure: bool = True):
        super().__init__()
        self.driver = driver
        self.seq = seq
        self.dwell = dwell
        self._abort = False
        self.measure = measure

        if not self.driver.is_connected():
            # Don't QMessageBox here; emit an error the UI can display
            self.error.emit("SweepWorker created but driver is not connected.")

    def run(self):
        try:
            if not self.driver.is_connected():
                self.error.emit("Not connected; aborting sweep.")
                return

            results = []
            n = len(self.seq)

            for i, val in enumerate(self.seq):
                if self._abort:
                    self.log.emit("Sweep aborted.")
                    break

                # Set current level immediately
                self.driver.send(f"SOUR:CURR:LEV {_fmt(val)}")

                # dwell
                self.msleep(int(max(0, self.dwell) * 1000))

                if self.measure:
                    # Replace with whatever you actually measure
                    resp = self.driver.query("SOUR:CURR:LEV?")
                    try:
                        results.append(float(resp))
                    except Exception:
                        results.append(resp)

                self.progress.emit(int((i + 1) * 100 / max(1, n)))

            self.finished.emit(results)

        except Exception as e:
            self.error.emit(str(e))


    def abort(self):
        self._abort = True


# ----------------- GUI -----------------
class FullApp(QMainWindow):
    _settings_loaded = pyqtSignal(dict)
    _load_error = pyqtSignal(str)
    _load_finished = pyqtSignal()
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Keithley 6221 — Complete Controller")
        self.resize(1400, 920)

        self.driver = FullDriver()
        self.driver.signals.cmd_result.connect(self._on_cmd_result)
        self.driver.signals.cmd_error.connect(self._on_cmd_error)
        self.driver.signals.log.connect(self._on_log)

        central = QWidget()
        self.setCentralWidget(central)
        main_l = QVBoxLayout(central)
        main_l.setContentsMargins(6,6,6,6)
        main_l.setSpacing(8)

        # Top row
        top = QHBoxLayout()
        self.res_combo = QComboBox()
        self.refresh_btn = QPushButton("Refresh")
        self.manual_res = QLineEdit()
        self.connect_btn = QPushButton("Connect")
        self.disconnect_btn = QPushButton("Disconnect")
        self.idn_label = QLabel("IDN: (n/c)")
        self.emergency_btn = QPushButton("EMERGENCY OFF")
        self.emergency_btn.setStyleSheet("background-color:#ff4444;font-weight:bold;")
        top.addWidget(QLabel("VISA Resource:"))
        top.addWidget(self.res_combo,1)
        top.addWidget(self.refresh_btn)
        top.addWidget(QLabel("Manual:"))
        top.addWidget(self.manual_res)
        top.addWidget(self.connect_btn)
        top.addWidget(self.disconnect_btn)
        top.addWidget(self.idn_label,2)
        top.addWidget(self.emergency_btn)
        main_l.addLayout(top)
        self._settings_loaded.connect(self._on_settings_loaded)
        self._load_error.connect(self._on_load_error)
        self._load_finished.connect(self._on_load_finished)
        # Tabs
        self.tabs = QTabWidget()
        main_l.addWidget(self.tabs,1)
        self.tabs.addTab(self._tab_main(), "Main")
        self.tabs.addTab(self._tab_trig_meas(), "Trigger & Measure")
        self.tabs.addTab(self._tab_list_sweep(), "LIST & Sweep")
        self.tabs.addTab(self._tab_guard(), "Guard & Wiring")
        self.tabs.addTab(self._tab_trace(), "Trace & Binary")
        self.tabs.addTab(self._tab_srq(), "SRQ & Events")
        self.tabs.addTab(self._tab_options(), "Firmware & Options")
        self.tabs.addTab(self._tab_route(), "Trigger Routing")
        self.tabs.addTab(self._tab_protection(), "Protection & Interlock")
        self.tabs.addTab(self._tab_advanced(), "Advanced")

        # Console
        self.console = QPlainTextEdit(); self.console.setReadOnly(True)
        main_l.addWidget(QLabel("Console Log:"))
        main_l.addWidget(self.console,2)

        # Hooks
        self.refresh_btn.clicked.connect(self._refresh_resources)
        self.connect_btn.clicked.connect(self._connect)
        self.disconnect_btn.clicked.connect(self._disconnect)
        self.emergency_btn.clicked.connect(self._emergency_off)

        # Periodic error poll
        if self._connect():
            self.err_timer = QTimer(self); self.err_timer.timeout.connect(self._poll_syst_err); self.err_timer.start(3000)

        self.sweep_worker: Optional[SweepWorker] = None
        self._trace_stream_stop: Optional[threading.Event] = None
        self._logfile = os.path.join(os.getcwd(), "keithley6221_complete.log")
        self._append("GUI started")
        self._refresh_resources()

    #def play_local_audio(self, audio_file_path=None):
  
     #   if not audio_file_path:
      #      print("Error: No audio file path provided")
       #     return

     # #audio_file_path = os.path.abspath(os.path.expanduser(audio_file_path))     
       # if not os.path.exists(audio_file_path):
       #     print(f"Error: Audio file not found at {audio_file_path}")
       #     return

     #   print(f"Attempting to play: {audio_file_path}")
        
    #    try:
   #         import subprocess
    #        if sys.platform == 'darwin':  # macOS
    #            subprocess.Popen(['afplay', audio_file_path])
    #        elif sys.platform == 'win32':  # Windows
    #            os.startfile(audio_file_path)
     #       else:  # Linux
    #            subprocess.Popen(['xdg-open', audio_file_path])
      #      print("Playback started successfully")
    #    except Exception as e:
      #      print(f"Error playing audio: {str(e)}")

    def _tab_main(self) -> QWidget:
        w = QWidget(); h = QHBoxLayout(w)
        left = QVBoxLayout(); left.addWidget(self._build_source_group()); left.addWidget(self._build_wave_group()); left.addStretch(1)
        right = QVBoxLayout(); right.addWidget(self._build_quick_controls()); right.addStretch(1)
        h.addLayout(left,2); h.addLayout(right,1)
        return w

    def _build_source_group(self) -> QGroupBox:
        g = QGroupBox("Source")
        f = QFormLayout()
        self.src_level = QDoubleSpinBox(); self.src_level.setDecimals(12); self.src_level.setRange(-1.0,1.0); self.src_level.setValue(0.001)
        self.src_unit = QComboBox(); self.src_unit.addItems(["A","mA","uA","nA","pA"])
        w = QWidget(); wh = QHBoxLayout(w); wh.setContentsMargins(0,0,0,0); wh.addWidget(self.src_level); wh.addWidget(self.src_unit)
        f.addRow("Level:", w)
        self.src_range_edit = QLineEdit(); self.src_range_edit.setPlaceholderText("AUTO or numeric")
        self.src_range_query = QPushButton("Query Range")
        re_w = QWidget(); reh = QHBoxLayout(re_w); reh.setContentsMargins(0,0,0,0); reh.addWidget(self.src_range_edit); reh.addWidget(self.src_range_query)
        f.addRow("Range:", re_w)
        self.src_range_query.clicked.connect(lambda: self.driver.queue("SOUR:CURR:RANG?"))
        self.autorange_chk = QCheckBox("Autorange")
        self.polarity_combo = QComboBox(); self.polarity_combo.addItems(["POS","NEG"])
        self.src_mode_combo = QComboBox(); self.src_mode_combo.addItems(["SOURCE","SINK","MULT"])
        aux_w = QWidget(); aux_h = QHBoxLayout(aux_w); aux_h.setContentsMargins(0,0,0,0); aux_h.addWidget(self.autorange_chk); aux_h.addWidget(QLabel("Polarity")); aux_h.addWidget(self.polarity_combo); aux_h.addWidget(QLabel("Mode")); aux_h.addWidget(self.src_mode_combo)
        f.addRow(aux_w)
        self.comp_spin = QDoubleSpinBox(); self.comp_spin.setRange(MIN_COMPLIANCE_V, MAX_COMPLIANCE_V); self.comp_spin.setDecimals(3); self.comp_spin.setValue(10.0)
        self.set_level_btn = QPushButton("Set Level")
        self.set_range_btn = QPushButton("Apply Range")
        self.set_comp_btn = QPushButton("Set Compliance")
        btn_w = QWidget(); bh = QHBoxLayout(btn_w); bh.setContentsMargins(0,0,0,0); bh.addWidget(self.set_level_btn); bh.addWidget(self.set_range_btn); bh.addWidget(self.set_comp_btn)
        f.addRow("Compliance (V):", self.comp_spin)
        f.addRow(btn_w)
        self.set_level_btn.clicked.connect(self._set_level)
        self.set_range_btn.clicked.connect(self._apply_range)
        self.set_comp_btn.clicked.connect(self._apply_comp)
        quick = QWidget(); qh = QHBoxLayout(quick); qh.setContentsMargins(0,0,0,0)
        self.out_on_btn = QPushButton("Output ON"); self.out_off_btn = QPushButton("Output OFF"); self.query_outp_btn = QPushButton("Query OUTP")
        qh.addWidget(self.out_on_btn); qh.addWidget(self.out_off_btn); qh.addWidget(self.query_outp_btn)
        self.out_on_btn.clicked.connect(lambda: self.driver.queue(command_map["output_on"]))
        self.out_off_btn.clicked.connect(lambda: self.driver.queue(command_map["output_off"]))
        self.query_outp_btn.clicked.connect(lambda: self.driver.queue(command_map["output_q"]))
        f.addRow(quick)
        g.setLayout(f)
        self.autorange_chk.stateChanged.connect(lambda s: self.driver.set_range("AUTO" if s else "OFF"))
        self.polarity_combo.currentTextChanged.connect(lambda p: self.driver.set_polarity(p))
        self.src_mode_combo.currentTextChanged.connect(lambda m: self.driver.queue(f"SOUR:FUNC:MODE {m}"))
        return g
    def apply_loaded_flat_to_ui(self, flat: dict[str, object]):
        self.blockSignals(True)
        try:
            applied = 0
            for key, val in flat.items():
                if val is None:
                    continue
                spec = self.driver.registry.get(key)
                if not spec or spec.widget is None:
                    continue

                w = spec.widget

                try:
                    # Spin boxes
                    if hasattr(w, "setValue"):
                        w.setValue(float(val))
                    # Checkboxes
                    elif hasattr(w, "setChecked"):
                        if isinstance(val, str) and val.strip().isdigit():
                            w.setChecked(bool(int(val.strip())))
                        else:
                            w.setChecked(bool(val))
                    # Combo boxes
                    elif hasattr(w, "setCurrentText"):
                        w.setCurrentText(str(val))
                    # Line edits
                    elif hasattr(w, "setText"):
                        w.setText(str(val))
                    else:
                        continue

                    applied += 1
                except Exception as e:
                    self._append(f"UI apply skip {key}: {e}")

            self._append(f"Loaded {applied} settings into UI")
        finally:
            self.blockSignals(False)

    def _build_wave_group(self) -> QGroupBox:
        g = QGroupBox("Waveform & Burst")
        f = QFormLayout()
        self.wave_type = QComboBox(); self.wave_type.addItems(["SINE","SQUARE","TRIANGLE","PULSE"])
        self.wave_amp = QDoubleSpinBox(); self.wave_amp.setRange(0, MAX_CURRENT_A); self.wave_amp.setDecimals(12)
        self.wave_freq = QDoubleSpinBox(); self.wave_freq.setRange(1e-6,1e6); self.wave_freq.setDecimals(6); self.wave_freq.setValue(1.0)
        self.wave_offs = QDoubleSpinBox(); self.wave_offs.setRange(-MAX_CURRENT_A, MAX_CURRENT_A); self.wave_offs.setDecimals(12)
        self.wave_phase = QDoubleSpinBox(); self.wave_phase.setRange(0,360); self.wave_phase.setValue(0)
        self.wave_duty = QDoubleSpinBox(); self.wave_duty.setRange(0.1,99.9); self.wave_duty.setDecimals(2); self.wave_duty.setValue(50)
        self.wave_burst_chk = QCheckBox("Burst")
        self.wave_burst_count = QSpinBox(); self.wave_burst_count.setRange(1,1000000); self.wave_burst_count.setValue(1)
        self.wave_burst_mode = QComboBox(); self.wave_burst_mode.addItems(["CONT","ONE"])
        self.wave_burst_trig = QComboBox(); self.wave_burst_trig.addItems(["IMM","EXT","BUS"])
        self.wave_burst_delay = QDoubleSpinBox(); self.wave_burst_delay.setDecimals(6); self.wave_burst_delay.setRange(0,1000); self.wave_burst_delay.setValue(0)
        self.wave_phase_mark = QCheckBox("Phase marker")
        self.wave_apply_btn = QPushButton("Apply Waveform")
        f.addRow("Type:", self.wave_type)
        f.addRow("Amplitude (A):", self.wave_amp)
        f.addRow("Freq (Hz):", self.wave_freq)
        f.addRow("Offset (A):", self.wave_offs)
        f.addRow("Phase (deg):", self.wave_phase)
        f.addRow("Duty (%):", self.wave_duty)
        b_w = QWidget(); bh = QHBoxLayout(b_w); bh.setContentsMargins(0,0,0,0)
        bh.addWidget(self.wave_burst_chk); bh.addWidget(QLabel("Count:")); bh.addWidget(self.wave_burst_count); bh.addWidget(QLabel("Mode:")); bh.addWidget(self.wave_burst_mode); bh.addWidget(QLabel("Trig:")); bh.addWidget(self.wave_burst_trig); bh.addWidget(QLabel("Delay:")); bh.addWidget(self.wave_burst_delay)
        f.addRow(b_w)
        f.addRow(self.wave_phase_mark)
        f.addRow(self.wave_apply_btn)
        self.wave_apply_btn.clicked.connect(self._apply_waveform)
        g.setLayout(f)
        return g

    def _build_quick_controls(self) -> QGroupBox:
        g = QGroupBox("Quick Controls")  # Initialize the QGroupBox
        v = QVBoxLayout()
        
        # Add save/load buttons
        btn_box = QHBoxLayout()
        self.btn_save = QPushButton("Save Settings")
        self.btn_load = QPushButton("Load Settings")
        self.btn_load_from_instr = QPushButton("Load from Instrument")
        
        # Add buttons to layout
        btn_box.addWidget(self.btn_save)
        btn_box.addWidget(self.btn_load)
        btn_box.addWidget(self.btn_load_from_instr)
        v.addLayout(btn_box)
        
        # Add existing controls
        self.terminator_read = QLineEdit()
        self.terminator_read.setPlaceholderText("\\n or \\r\\n")
        self.terminator_write = QLineEdit()
        self.terminator_write.setPlaceholderText("\\n or \\r\\n")
        self.set_terms_btn = QPushButton("Set Terminators")
        self.set_eoi_chk = QCheckBox("EOI on write")
        self.visa_timeout = QSpinBox()
        self.visa_timeout.setRange(100, 600000)
        self.visa_timeout.setValue(5000)
        
        # Add existing controls to layout
        v.addWidget(QLabel("Read Term:"))
        v.addWidget(self.terminator_read)
        v.addWidget(QLabel("Write Term:"))
        v.addWidget(self.terminator_write)
        v.addWidget(self.set_terms_btn)
        v.addWidget(self.set_eoi_chk)
        v.addWidget(QLabel("VISA timeout (ms):"))
        v.addWidget(self.visa_timeout)
        
        # Connect buttons
        self.btn_save.clicked.connect(self._save_settings_ui)
        self.btn_load.clicked.connect(self._load_settings_ui)
        self.btn_load_from_instr.clicked.connect(self._load_from_instrument)
        self.set_terms_btn.clicked.connect(self._apply_terminators)
        self.set_eoi_chk.stateChanged.connect(lambda s: self.driver.set_eoi(bool(s)))
        self.visa_timeout.valueChanged.connect(lambda t: self.driver.set_timeout(int(t)))
        
        # Set layout to group box
        g.setLayout(v)
        return g


    def load_thread(self):
        try:
            settings = {'source': {}, 'waveform': {}, 'trigger': {}}
            
            # Get source settings
            settings['source']['level'] = float(self.driver.query("SOUR:CURR:LEV:AMPL?"))
            settings['source']['compliance'] = float(self.driver.query("SOUR:CURR:COMP?"))
            settings['source']['autorange'] = self.driver.query("SOUR:CURR:RANG:AUTO?").strip().upper() == "1"
            settings['source']['polarity'] = self.driver.query("SOUR:CURR:POL?").strip()
            settings['source']['mode'] = self.driver.query("SOUR:FUNC:MODE?").strip()
            
            # Get waveform settings
            settings['waveform']['type'] = self.driver.query("SOUR:WAVE:FUNC?").strip('"').upper()
            settings['waveform']['amplitude'] = float(self.driver.query("SOUR:WAVE:AMPL?"))
            settings['waveform']['frequency'] = float(self.driver.query("SOUR:WAVE:FREQ?"))
            settings['waveform']['offset'] = float(self.driver.query("SOUR:WAVE:OFFS?"))
            settings['waveform']['phase'] = float(self.driver.query("SOUR:WAVE:PHAS?"))
            settings['waveform']['duty'] = float(self.driver.query("SOUR:WAVE:DCYC?"))
            
            # Get trigger settings
            settings['trigger']['source'] = self.driver.query("TRIG:SOUR?").strip()
            settings['trigger']['slope'] = self.driver.query("TRIG:SLOP?").strip()
            settings['trigger']['level'] = float(self.driver.query("TRIG:LEV?"))
            settings['trigger']['delay'] = float(self.driver.query("TRIG:DEL?"))
            settings['trigger']['count'] = int(self.driver.query("TRIG:COUN?"))
            
            # Emit signal with the loaded settings
            self._settings_loaded.emit(settings)
            
        except Exception as e:
            # Emit error signal
            self._load_error.emit(str(e))
        finally:
            # Emit finished signal
            self._load_finished.emit()

    @pyqtSlot(dict)
    def _on_settings_loaded(self, settings):
        """Handle successful settings load"""
        try:
            self.apply_settings(settings, apply_to_instrument=False)
            self._append("Settings loaded from instrument")
        except Exception as e:
            self._append(f"Error applying settings: {str(e)}")
            QMessageBox.critical(self, "Error", f"Failed to apply settings: {str(e)}")

    @pyqtSlot(str)
    def _on_load_error(self, error_msg):
        """Handle load error"""
        QMessageBox.critical(self, "Error", f"Failed to load settings from instrument: {error_msg}")
        self._append(f"Error loading from instrument: {error_msg}")

    @pyqtSlot()
    def _on_load_finished(self):
        """Clean up after load attempt"""
        self.btn_load_from_instr.setEnabled(True)
        self.btn_load_from_instr.setText("Load from Instrument")

    # ----- Trigger & Meas Tab -----
    def _tab_trig_meas(self) -> QWidget:
        w = QWidget(); v = QVBoxLayout(w)
        trig_g = QGroupBox("Trigger")
        tf = QFormLayout()
        self.trig_src = QComboBox(); self.trig_src.addItems(["IMM","EXT","BUS","MAN"])
        self.trig_slope = QComboBox(); self.trig_slope.addItems(["POS","NEG"])
        self.trig_level = QDoubleSpinBox(); self.trig_level.setDecimals(6); self.trig_level.setRange(-100, 100)
        self.trig_delay = QDoubleSpinBox(); self.trig_delay.setDecimals(6); self.trig_delay.setRange(0,1000)
        self.trig_count = QSpinBox(); self.trig_count.setRange(1,1000000); self.trig_count.setValue(1)
        self.trig_apply = QPushButton("Apply Trigger")
        tf.addRow("Source:", self.trig_src); tf.addRow("Slope:", self.trig_slope); tf.addRow("Level:", self.trig_level); tf.addRow("Delay(s):", self.trig_delay); tf.addRow("Count:", self.trig_count); tf.addRow(self.trig_apply)
        trig_g.setLayout(tf)
        self.trig_apply.clicked.connect(self._apply_trigger)
        v.addWidget(trig_g)

        meas_g = QGroupBox("Measurement")
        mf = QFormLayout()
        self.meas_func = QComboBox(); self.meas_func.addItems(["MEAS:VOLT?","MEAS:CURR?"])
        self.nplc_spin = QDoubleSpinBox(); self.nplc_spin.setRange(0.0001,10); self.nplc_spin.setDecimals(6); self.nplc_spin.setValue(0.1)
        self.aver_enable = QCheckBox("Enable Averaging")
        self.aver_count = QSpinBox(); self.aver_count.setRange(1,1000); self.aver_count.setValue(10)
        self.filter_enable = QCheckBox("Analog Filter")
        self.filter_time = QDoubleSpinBox(); self.filter_time.setRange(0,100); self.filter_time.setDecimals(6); self.filter_time.setValue(0.0)
        self.meas_read = QPushButton("Single Read")
        mf.addRow("Function:", self.meas_func)
        mf.addRow("NPLC:", self.nplc_spin)
        mf.addRow(self.aver_enable, self.aver_count)
        mf.addRow(self.filter_enable, self.filter_time)
        mf.addRow(self.meas_read)
        self.meas_read.clicked.connect(lambda: self.driver.queue(self.meas_func.currentText()))
        self.aver_enable.stateChanged.connect(lambda s: self.driver.queue(command_map["sens_aver_stat"].format(onoff="ON" if s else "OFF")))
        self.aver_count.valueChanged.connect(lambda v: self.driver.queue(command_map["sens_aver_count"].format(val=int(v))))
        meas_g.setLayout(mf)
        v.addWidget(meas_g)
        return w

    # ----- LIST & Sweep Tab -----
    def _tab_list_sweep(self) -> QWidget:
        w = QWidget(); v = QVBoxLayout(w)
        list_g = QGroupBox("LIST Manager")
        lv = QVBoxLayout()
        self.list_editor = QPlainTextEdit()
        self.list_chunked = QCheckBox("Chunked Upload")
        self.list_chunk_size = QSpinBox(); self.list_chunk_size.setRange(10,10000); self.list_chunk_size.setValue(1000)
        self.list_slot = QSpinBox(); self.list_slot.setRange(0,9)
        self.list_upload_btn = QPushButton("Upload LIST")
        self.list_import = QPushButton("Import CSV")
        self.list_export = QPushButton("Export CSV")
        lh = QWidget(); lhh = QHBoxLayout(lh); lhh.setContentsMargins(0,0,0,0)
        lhh.addWidget(QLabel("Slot:")); lhh.addWidget(self.list_slot); lhh.addWidget(self.list_chunked); lhh.addWidget(QLabel("Chunk size:")); lhh.addWidget(self.list_chunk_size); lhh.addWidget(self.list_upload_btn)
        lh2 = QWidget(); lhh2 = QHBoxLayout(lh2); lhh2.setContentsMargins(0,0,0,0); lhh2.addWidget(self.list_import); lhh2.addWidget(self.list_export)
        lv.addWidget(self.list_editor); lv.addWidget(lh); lv.addWidget(lh2)
        list_g.setLayout(lv)
        self.list_upload_btn.clicked.connect(self._upload_list)
        self.list_import.clicked.connect(self._import_list); self.list_export.clicked.connect(self._export_list)
        v.addWidget(list_g)

        sweep_g = QGroupBox("Sweep")
        sv = QFormLayout()
        self.swp_type = QComboBox(); self.swp_type.addItems(["LINEAR","LOG","STEP","LIST"])
        self.swp_start = QDoubleSpinBox(); self.swp_start.setDecimals(12)
        self.swp_stop = QDoubleSpinBox(); self.swp_stop.setDecimals(12)
        self.swp_step = QDoubleSpinBox(); self.swp_step.setDecimals(12)
        self.swp_points = QSpinBox(); self.swp_points.setRange(2,200000); self.swp_points.setValue(50)
        self.swp_dwell = QDoubleSpinBox(); self.swp_dwell.setDecimals(6); self.swp_dwell.setRange(0.0,3600.0); self.swp_dwell.setValue(0.1)
        sv.addRow("Type:", self.swp_type); sv.addRow("Start (A):", self.swp_start); sv.addRow("Stop (A):", self.swp_stop); sv.addRow("Step (A):", self.swp_step); sv.addRow("Points:", self.swp_points); sv.addRow("Dwell:", self.swp_dwell)
        sh = QWidget(); shh = QHBoxLayout(sh); shh.setContentsMargins(0,0,0,0)
        self.swp_preview = QPushButton("Preview"); self.swp_init = QPushButton("INIT"); self.swp_arm = QPushButton("ARM"); self.swp_abort = QPushButton("ABOR")
        shh.addWidget(self.swp_preview); shh.addWidget(self.swp_init); shh.addWidget(self.swp_arm); shh.addWidget(self.swp_abort)
        sv.addRow(sh)
        self.swp_preview.clicked.connect(self._preview_sweep)
        self.swp_init.clicked.connect(self._start_sweep)
        self.swp_arm.clicked.connect(lambda: self.driver.queue("ARM"))
        self.swp_abort.clicked.connect(lambda: self.driver.queue("ABOR"))
        sweep_g.setLayout(sv)
        v.addWidget(sweep_g)
        return w

    # ----- Guard & Wiring Tab -----
    def _tab_guard(self) -> QWidget:
        w = QWidget(); v = QVBoxLayout(w)
        gb = QGroupBox("Guard & Wiring")
        f = QFormLayout()
        self.guard_enable_chk = QCheckBox("Enable Guard")
        self.float_output_chk = QCheckBox("Float Output")
        self.guard_help_btn = QPushButton("Show Wiring Help")
        f.addRow(self.guard_enable_chk)
        f.addRow(self.float_output_chk)
        f.addRow(self.guard_help_btn)
        gb.setLayout(f)
        v.addWidget(gb)
        # Add in Guard & Wiring UI:
        self.guard_safety_ack = QCheckBox("I have read the wiring guidance and accept responsibility")
        self.guard_enable_chk.setEnabled(False)  # enable only after acknowledge
        f.addRow(self.guard_safety_ack)
        # connect acknowledgment toggle
        self.guard_safety_ack.stateChanged.connect(lambda s: self.guard_enable_chk.setEnabled(bool(s)))
        # enforce mutual exclusivity: if both float and guard could cause hazard, block
        self.float_output_chk.stateChanged.connect(self._guard_float_check)


        self.guard_enable_chk.stateChanged.connect(lambda s: self.driver.set_guard(bool(s)))
        self.float_output_chk.stateChanged.connect(lambda s: self.driver.set_output_floating(bool(s)))
        self.guard_help_btn.clicked.connect(lambda: QMessageBox.information(self, "Guard wiring", "Refer to the Keithley manual section on guard/sense wiring for diagrams and safety guidance."))
        return w

    def _guard_float_check(self, state):
        if self.float_output_chk.isChecked() and self.guard_enable_chk.isChecked():
            # warn and block if unsafe; require explicit confirmation
            reply = QMessageBox.warning(self, "Potential hazard", "Floating output with guard may be hazardous. Continue?", QMessageBox.Yes | QMessageBox.No)
            if reply != QMessageBox.Yes:
                self.float_output_chk.setChecked(False)

    # ----- Trace & Binary Tab -----
    def _tab_trace(self) -> QWidget:
        w = QWidget(); v = QVBoxLayout(w)
        tg = QGroupBox("Trace & Binary")
        vf = QFormLayout()
        self.trace_feed = QComboBox(); self.trace_feed.addItems(["SENSE","SOURCE"])
        self.trace_points = QSpinBox(); self.trace_points.setRange(1,1000000); self.trace_points.setValue(1000)
        self.trace_buf = QLineEdit("defbuffer1")
        vf.addRow("Feed:", self.trace_feed); vf.addRow("Points:", self.trace_points); vf.addRow("Buffer:", self.trace_buf)
        btn_cfg = QPushButton("Configure Trace"); btn_read = QPushButton("Read Trace (ASCII)"); btn_read_bin = QPushButton("Read Trace (Binary)")
        btn_stream = QPushButton("Start Stream to File"); btn_stop_stream = QPushButton("Stop Stream")
        vf.addRow(btn_cfg); vf.addRow(btn_read); vf.addRow(btn_read_bin); vf.addRow(btn_stream); vf.addRow(btn_stop_stream)
        tg.setLayout(vf); v.addWidget(tg)
        btn_cfg.clicked.connect(lambda: self.driver.configure_trace(self.trace_feed.currentText(), int(self.trace_points.value()), self.trace_buf.text()))
        btn_read.clicked.connect(lambda: self.driver.read_trace_ascii(1, int(self.trace_points.value()), self.trace_buf.text()))
        btn_read_bin.clicked.connect(lambda: threading.Thread(target=self._do_binary_trace_read, daemon=True).start())
        btn_stream.clicked.connect(self._start_trace_stream_ui)
        btn_stop_stream.clicked.connect(self._stop_trace_stream_ui)
        return w

    def _do_binary_trace_read(self):
        try:
            raw = self.driver.query_binary_raw(f"TRAC:DATA? 1,{self.trace_points.value()},\"{self.trace_buf.text()}\"")
            if isinstance(raw, (bytes, bytearray)):
                payload = self.driver.parse_ieee488_binary_block(raw)
                self._append(f"Binary trace read {len(payload)} bytes")
            else:
                self._append(f"Binary trace read (non-bytes) len {len(str(raw))}")
        except Exception as e:
            self._append(f"Binary trace read failed: {e}")

    def _start_trace_stream_ui(self):
        p, _ = QFileDialog.getSaveFileName(self, "Stream Trace to", os.getcwd(), "CSV Files (*.csv)")
        if not p: return
        if self._trace_stream_stop and not self._trace_stream_stop.is_set():
            QMessageBox.information(self, "Streaming", "Already streaming")
            return
        self._trace_stream_stop = threading.Event()
        self.driver.stream_trace_to_file(p, buffer_name=self.trace_buf.text(), chunk_size=1000, interval_s=1.0, stop_event=self._trace_stream_stop)
        self._append(f"Started streaming trace to {p}")

    def _stop_trace_stream_ui(self):
        if self._trace_stream_stop:
            self._trace_stream_stop.set()
            self._append("Trace stream stop requested")

    # ----- SRQ & Events Tab -----
    def _tab_srq(self) -> QWidget:
        w = QWidget(); v = QVBoxLayout(w)
        gb = QGroupBox("SRQ & Event Registers")
        f = QFormLayout()
        self.ese_spin = QSpinBox(); self.ese_spin.setRange(0,65535)
        self.sre_spin = QSpinBox(); self.sre_spin.setRange(0,65535)
        set_ese = QPushButton("Set ESE"); set_sre = QPushButton("Set SRE"); read_stat = QPushButton("Read STAT registers")
        f.addRow("ESE Mask:", self.ese_spin); f.addRow(set_ese); f.addRow("SRE Mask:", self.sre_spin); f.addRow(set_sre); f.addRow(read_stat)
        gb.setLayout(f); v.addWidget(gb)
        # In FullApp._tab_srq, add:
        self.ese_read_btn = QPushButton("Read ESE/SRE")
        self.ese_write_btn = QPushButton("Write ESE from Mask")
        self.srq_bits_editor = QPlainTextEdit()  # simple bit->label editor; one "mask,label" per line
        f.addRow(self.ese_read_btn); f.addRow(self.ese_write_btn); f.addRow(QLabel("Bit mapping (mask,label)"), self.srq_bits_editor)

        self.ese_read_btn.clicked.connect(lambda: threading.Thread(target=self._read_ese_sre_ui, daemon=True).start())
        self.ese_write_btn.clicked.connect(lambda: self.driver.set_event_status_enable(int(self.ese_spin.value())))

        set_ese.clicked.connect(lambda: self.driver.set_event_status_enable(int(self.ese_spin.value())))
        set_sre.clicked.connect(lambda: self.driver.set_service_request_enable(int(self.sre_spin.value())))
        read_stat.clicked.connect(lambda: self.driver.read_event_registers())
        return w
    def _read_ese_sre_ui(self):
        info = self.driver.read_ese_sre()
        regs = self.driver.read_status_registers()
        dec = {}
        try:
            if regs.get("ques") is not None:
                qval = int(regs["ques"])
                dec = self.driver.decode_event_bits(qval)
        except Exception:
            pass
        self._append(f"ESE/SRE: {info} ; STATUS: {regs} ; DECODE: {dec}")

    # ----- Options & Firmware Tab -----
    def _tab_options(self) -> QWidget:
        w = QWidget(); v = QVBoxLayout(w)
        gb = QGroupBox("Firmware & Options")
        f = QFormLayout()
        self.q_idn_btn = QPushButton("Query IDN and Options")
        self.idn_display = QLineEdit()
        f.addRow(self.q_idn_btn); f.addRow(self.idn_display)
        gb.setLayout(f); v.addWidget(gb)
        self.q_idn_btn.clicked.connect(lambda: threading.Thread(target=self._query_options_ui, daemon=True).start())
        return w

    def _query_options_ui(self):
        info = self.driver.query_options_and_firmware()
        self.idn_display.setText(info.get("idn",""))
        self._append(f"Options/firmware: {info}")
        # Example gating
        info = self.driver.query_options_and_firmware()
        opts = info.get("options", [])
        # if 'TRACEX' not in opts then disable trace streaming features
        if "TRAC" not in ",".join(opts).upper():
            self.trace_feed.setEnabled(False)
            self.trace_points.setEnabled(False)
            self._append("Trace controls disabled (firmware options not present)")


    # ----- Trigger Routing Tab -----
    def _tab_route(self) -> QWidget:
        w = QWidget(); v = QVBoxLayout(w)
        gb = QGroupBox("Trigger Routing")
        f = QFormLayout()
        self.troute_spec = QTextEdit()
        self.troute_apply = QPushButton("Apply Route Spec")
        f.addRow(QLabel("Route SCPI line:"), self.troute_spec)
        f.addRow(self.troute_apply)
        gb.setLayout(f); v.addWidget(gb)
        self.troute_apply.clicked.connect(lambda: self.driver.set_trigger_output_route(self.troute_spec.toPlainText().strip()))
        return w

    # ----- Protection Tab -----
    def _tab_protection(self) -> QWidget:
        w = QWidget(); v = QVBoxLayout(w)
        gb = QGroupBox("Protection & Interlock")
        f = QFormLayout()
        self.read_prot_btn = QPushButton("Read Protection State")
        self.prot_display = QLineEdit()
        f.addRow(self.read_prot_btn); f.addRow(self.prot_display)
        gb.setLayout(f); v.addWidget(gb)
        self.read_prot_btn.clicked.connect(lambda: threading.Thread(target=self._read_prot_ui, daemon=True).start())
        return w

    def _read_prot_ui(self):
        st = self.driver.read_protection_state()
        self.prot_display.setText(str(st))
        self._append(f"Protection: {st}")

    # ----- Advanced Tab -----
    def _tab_advanced(self) -> QWidget:
        w = QWidget(); v = QVBoxLayout(w)
        diag_g = QGroupBox("Diagnostics")
        dh = QHBoxLayout()
        self.self_test_btn = QPushButton("Self Test (*TST?)"); self.diag_btn = QPushButton("SYST:DIAG?")
        dh.addWidget(self.self_test_btn); dh.addWidget(self.diag_btn)
        diag_g.setLayout(dh)
        v.addWidget(diag_g)
        buf_g = QGroupBox("Trace / Buffer")
        bf = QHBoxLayout()
        self.buf_clear = QPushButton("Clear Trace")
        self.buf_read = QPushButton("Read Trace (ASCII)")
        self.buf_read_bin = QPushButton("Read Trace (Binary)")
        self.buf_save = QPushButton("Save Trace to File")
        bf.addWidget(self.buf_clear); bf.addWidget(self.buf_read); bf.addWidget(self.buf_read_bin); bf.addWidget(self.buf_save)
        buf_g.setLayout(bf)
        v.addWidget(buf_g)
        self.self_test_btn.clicked.connect(lambda: self.driver.queue(command_map["self_test"]))
        self.diag_btn.clicked.connect(lambda: self.driver.queue(command_map["diag"]))
        self.buf_clear.clicked.connect(lambda: self.driver.queue(command_map["trac_cle"]))
        self.buf_read.clicked.connect(lambda: self.driver.queue("TRAC:DATA? 1,1000,\"defbuffer1\""))
        self.buf_read_bin.clicked.connect(lambda: threading.Thread(target=self._do_binary_trace_read, daemon=True).start())
        self.buf_save.clicked.connect(self._save_trace_file)
        return w

    def _save_trace_file(self):
        p, _ = QFileDialog.getSaveFileName(self, "Save Trace", os.getcwd(), "CSV Files (*.csv)")
        if not p: return
        def rd_save():
            try:
                data = self.driver.query("TRAC:DATA? 1,100000,\"defbuffer1\"")
                with open(p, "w") as f: f.write(str(data) + "\n")
                self._append(f"Trace saved {p}")
            except Exception as e:
                self._append(f"Trace save failed: {e}")
        threading.Thread(target=rd_save, daemon=True).start()

    # ----- Actions & helpers -----
    def _refresh_resources(self):
        self.res_combo.clear()
        try:
            res = self.driver.list_resources()
            self.res_combo.addItems(res)
            self._append(f"Resources: {res}")
        except Exception as e:
            self._append(f"Resource refresh error: {e}")

    def _connect(self):
        res = self.manual_res.text().strip() or self.res_combo.currentText().strip()
        if not res:
            return
        try:
            self.driver.connect(res)
            self.driver.queue(command_map["idn"])
        except Exception as e:
            QMessageBox.critical(self, "Connect failed", str(e))

    def _disconnect(self):
        try:
            self.driver.close()
            self.idn_label.setText("IDN: (n/c)")
        except Exception as e:
            self._append(f"Disconnect error: {e}")

    def _emergency_off(self):
        try:
            self.driver.queue(command_map["output_off"])
            self.driver.queue("ABOR")
            self._append("Emergency OFF issued (OUTP OFF + ABOR)")
        except Exception as e:
            self._append(f"Emergency failed: {e}")

    # Source actions
    def _set_level(self):
        try:
            level = float(self.src_level.value())

            if not self.driver.is_connected():
                QMessageBox.warning(self, "Error", "Instrument not connected.")
                return

            # Use the driver like every other button
            self.driver.set_current(level)

            # Optional readback (queued so it shows in console via cmd_result)
            self.driver.queue("SOUR:CURR:LEV?")

            self._append(f"Queued current level set: {level} A")

        except Exception as e:
            QMessageBox.critical(self, "Set level error", str(e))



    def _apply_range(self):
        rng = self.src_range_edit.text().strip()
        if not rng:
            QMessageBox.warning(self, "Range", "Enter AUTO or numeric")
            return
        self.driver.set_range(rng)
        self._append(f"Range applied: {rng}")

    def _apply_comp(self):
        try:
            v = float(self.comp_spin.value())
            if v < MIN_COMPLIANCE_V or v > MAX_COMPLIANCE_V:
                QMessageBox.warning(self, "Compliance", f"Compliance must be between {MIN_COMPLIANCE_V} and {MAX_COMPLIANCE_V} V")
                return
            self.driver.set_compliance(v)
            self._append(f"Set compliance: {v} V")
        except Exception as e:
            QMessageBox.critical(self, "Compliance error", str(e))

    def _apply_waveform(self):
        try:
            params = {
                "type": self.wave_type.currentText(),
                "amp": float(self.wave_amp.value()),
                "freq": float(self.wave_freq.value()),
                "offset": float(self.wave_offs.value()),
                "phase": float(self.wave_phase.value()),
                "duty": float(self.wave_duty.value()),
                "burst_on": bool(self.wave_burst_chk.isChecked()),
                "burst_count": int(self.wave_burst_count.value()),
                "burst_mode": self.wave_burst_mode.currentText(),
                "burst_trigger": self.wave_burst_trig.currentText(),
                "burst_delay": float(self.wave_burst_delay.value()),
                "phase_marker": bool(self.wave_phase_mark.isChecked())
            }
            if abs(params["amp"]) > MAX_CURRENT_A:
                QMessageBox.warning(self, "Amplitude", f"Exceeds device max {MAX_CURRENT_A} A")
                return
            self.driver.configure_wave(params)
            self._append("Waveform configure queued")
        except Exception as e:
            QMessageBox.critical(self, "Waveform error", str(e))

    def _apply_trigger(self):
        src = self.trig_src.currentText(); slope = self.trig_slope.currentText(); level = float(self.trig_level.value()); delay = float(self.trig_delay.value()); count = int(self.trig_count.value())
        self.driver.queue(command_map["trig_source"].format(src=src))
        self.driver.queue(command_map["trig_delay"].format(val=_fmt(delay)))
        self.driver.queue(command_map["trig_count"].format(val=count))
        self.driver.queue(f"TRIG:SLOP {slope}")
        self.driver.queue(f"TRIG:LEV {_fmt(level)}")
        self._append("Trigger configured queued")

    # LIST manager actions
    def _upload_list(self):
        text = self.list_editor.toPlainText().strip()
        if not text:
            QMessageBox.warning(self, "Empty", "Enter list values")
            return
        try:
            vals = [float(l.strip()) for l in text.splitlines() if l.strip()]
            if any(abs(v) > MAX_CURRENT_A for v in vals):
                QMessageBox.warning(self, "Value out of range", "List contains values outside device limits")
                return
            chunked = bool(self.list_chunked.isChecked()); chunk_size = int(self.list_chunk_size.value())
            def upl():
                try:
                    self.driver.upload_list(vals, chunked=chunked, chunk_size=chunk_size, progress_cb=lambda s,t: self._append(f"Uploaded {s}/{t}"))
                    self._append("List upload queued")
                except Exception as e:
                    self._append(f"Upload failed: {e}")
            threading.Thread(target=upl, daemon=True).start()
        except Exception as e:
            QMessageBox.critical(self, "Parse error", str(e))

    def _import_list(self):
        p, _ = QFileDialog.getOpenFileName(self, "Import list", os.getcwd(), "CSV Files (*.csv);;All Files (*)")
        if not p: return
        try:
            with open(p, "r") as f:
                txt = f.read().strip()
            vals = txt.replace(",", "\n").splitlines()
            self.list_editor.setPlainText("\n".join(v.strip() for v in vals if v.strip()))
            self._append(f"Imported {len(vals)} values from {p}")
        except Exception as e:
            self._append(f"Import failed: {e}")

    def _export_list(self):
        p, _ = QFileDialog.getSaveFileName(self, "Export list", os.getcwd(), "CSV Files (*.csv)")
        if not p: return
        try:
            txt = self.list_editor.toPlainText().strip()
            if not txt:
                QMessageBox.warning(self, "Empty", "No list to export")
                return
            vals = [v.strip() for v in txt.splitlines() if v.strip()]
            with open(p, "w") as f:
                f.write(",".join(vals))
            self._append(f"Exported list to {p}")
        except Exception as e:
            self._append(f"Export failed: {e}")

    # Sweep preview/start
    def _preview_sweep(self):
        typ = self.swp_type.currentText()
        if typ == "LIST":
            text = self.list_editor.toPlainText().strip()
            if not text:
                QMessageBox.warning(self, "Empty", "Provide list")
                return
            vals = [float(l) for l in text.splitlines() if l.strip()]
            self._append(f"Preview LIST: {len(vals)} points, min {min(vals)} max {max(vals)}")
        else:
            start = float(self.swp_start.value()); stop = float(self.swp_stop.value()); step = float(self.swp_step.value())
            if step == 0:
                QMessageBox.warning(self, "Step=0", "Step cannot be zero")
                return
            n = int(abs((stop - start) / step)) + 1
            self._append(f"Preview {typ}: {n} points from {start} to {stop} step {step}")

    def _start_sweep(self):
        typ = self.swp_type.currentText()
        dwell = float(self.swp_dwell.value())
        seq: List[float] = []
        if typ == "LIST":
            text = self.list_editor.toPlainText().strip()
            if not text:
                QMessageBox.warning(self, "Empty", "Provide list")
                return
            seq = [float(l.strip()) for l in text.splitlines() if l.strip()]
        else:
            start = float(self.swp_start.value()); stop = float(self.swp_stop.value()); step = float(self.swp_step.value())
            if step == 0:
                QMessageBox.warning(self, "Invalid", "Step cannot be zero")
                return
            n = int(abs((stop - start) / step)) + 1
            if n > 200000:
                QMessageBox.warning(self, "Too many points", "Reduce points")
                return
            seq = [start + i * (stop - start) / max(1, n - 1) for i in range(n)]
        seq = [math.copysign(MAX_CURRENT_A, v) if abs(v) > MAX_CURRENT_A else v for v in seq]
        if hasattr(self, "sweep_worker") and self.sweep_worker and self.sweep_worker.isRunning():
            QMessageBox.warning(self, "Running", "Abort current sweep first")
            return
        self.sweep_worker = SweepWorker(self.driver, seq, dwell, measure=True)
        self.sweep_worker.progress.connect(lambda p: None)
        self.sweep_worker.log.connect(self._append)
        self.sweep_worker.error.connect(self._append)
        self.sweep_worker.finished.connect(lambda r: self._append(f"Sweep finished {len(r)} pts"))
        self.sweep_worker.start()
        self._append("Sweep started")

    # Comm & trace helpers
    def _apply_terminators(self):
        r = self.terminator_read.text()
        w = self.terminator_write.text()
        r_eval = r.encode('utf-8').decode('unicode_escape') if r else "\n"
        w_eval = w.encode('utf-8').decode('unicode_escape') if w else "\n"
        self.driver.set_terminators(r_eval, w_eval)
        self._append(f"Terminators set R:'{r_eval}' W:'{w_eval}'")

    def _apply_comm(self):
        try:
            # apply if present in command_map; else use common tokens
            if "comm_gpib_addr" in command_map:
                self.driver.queue(command_map["comm_gpib_addr"].format(addr=int(self.gpib_addr.value())))
            else:
                self.driver.queue(f"SYST:COMM:GPIB:ADDR {int(self.gpib_addr.value())}")
            self._append("Comm queued")
        except Exception as e:
            self._append(f"Comm apply failed: {e}")

    # Trace binary helpers above

    # Options query
    def _query_options_ui(self):
        info = self.driver.query_options_and_firmware()
        self._append(f"Options/firmware: {info}")
        try:
            self.idn_label.setText(f"IDN: {info.get('idn','')}")
        except Exception:
            pass

    # Protection UI done above

    # Polling and driver callbacks
    def _poll_syst_err(self):
        if not self.driver.is_connected(): 
            self._append("Not connected; skipping SYST:ERR poll")
            return
        resp = self.instrument.query("SYST:ERR?")
        self._append(f"SYST:ERR -> {resp}")

    def _on_cmd_result(self, cmd: str, resp: object):
        if resp is None:
            self._append(f"Sent: {cmd}")
        else:
            self._append(f"Reply: {cmd} -> {resp}")
            if cmd.strip().upper().startswith("SYST:ERR"):
                s = str(resp)
                if not s.startswith("0"):
                    cls = self.driver.classify_syst_err(s)
                    QMessageBox.critical(self, "Instrument error", f"{s}\nSeverity: {cls.get('severity')}")
            if cmd.strip().upper().startswith("*IDN"):
                try:
                    self.idn_label.setText(f"IDN: {resp}")
                except Exception:
                    pass

    def _on_cmd_error(self, cmd: str, err: str):
        self._append(f"Command error '{cmd}': {err}")

    def _on_log(self, msg: str):
        self._append(msg)

    def _append(self, msg: str):
        ts = time.strftime("%Y-%m-%d %H:%M:%S")
        line = f"[{ts}] {msg}"
        try:
            self.console.appendPlainText(line)
        except Exception:
            pass
        try:
            with open(self._logfile, "a") as f:
                f.write(line + "\n")
        except Exception:
            pass

    def _load_from_instrument(self):
        """Load current settings from the connected instrument (paced + safe)."""
        if not hasattr(self.driver, "is_connected") or not self.driver.is_connected():
            QMessageBox.warning(self, "Not Connected", "Not connected to instrument")
            return

        # UI state
        self.btn_load_from_instr.setEnabled(False)
        self.btn_load_from_instr.setText("Loading...")
        QApplication.processEvents()

        # --- timeout bump ONLY for this operation ---
        old_timeout = getattr(getattr(self.driver, "inst", None), "timeout", None)

        def q(cmd: str, delay_ms: int = 40) -> str:
            """Query with pacing to avoid overloading the instrument."""
            resp = self.driver.query(cmd)
            QThread.msleep(delay_ms)
            QApplication.processEvents()
            return resp

        def safe(name: str, fn):
            """Never crash the whole load on one bad query."""
            try:
                return fn()
            except Exception as e:
                self._append(f"Load skip {name}: {e}")
                return None

        try:
            try:
                if self.driver.inst is not None:
                    self.driver.inst.timeout = 20000  # 20s for slow queries during load
            except Exception:
                pass

            # --- SOURCE ---
            level = safe("source.current.level", lambda: float(q("SOUR:CURR:LEV?")))
            if level is not None and hasattr(self, "src_level"):
                self.src_level.setValue(level)

            compliance = safe("source.compliance.voltage", lambda: float(q("SOUR:VOLT:PROT?")))
            if compliance is not None and hasattr(self, "comp_spin"):
                self.comp_spin.setValue(compliance)

            autorange_raw = safe("source.current.autorange", lambda: q("SOUR:CURR:RANG:AUTO?").strip())
            if autorange_raw is not None and hasattr(self, "autorange_chk"):
                self.autorange_chk.setChecked(autorange_raw.upper() in ("1", "ON", "TRUE"))

            rng_raw = safe("source.current.range", lambda: q("SOUR:CURR:RANG?").strip())
            if rng_raw is not None and hasattr(self, "src_range_edit"):
                self.src_range_edit.setText(rng_raw)

            outp_raw = safe("source.output.enabled", lambda: q("OUTP?").strip())
            if outp_raw is not None and hasattr(self, "outp_enable"):
                self.outp_enable.setChecked(outp_raw.upper() in ("1", "ON", "TRUE"))

            # --- WAVEFORM (only if you have these widgets) ---
            w_type = safe("waveform.type", lambda: q("SOUR:WAVE:FUNC?").strip().strip('"'))
            if w_type is not None and hasattr(self, "wave_type"):
                self.wave_type.setCurrentText(w_type)

            w_amp = safe("waveform.amplitude", lambda: float(q("SOUR:WAVE:AMPL?")))
            if w_amp is not None and hasattr(self, "wave_amp"):
                self.wave_amp.setValue(w_amp)

            w_freq = safe("waveform.frequency", lambda: float(q("SOUR:WAVE:FREQ?")))
            if w_freq is not None and hasattr(self, "wave_freq"):
                self.wave_freq.setValue(w_freq)

            w_offs = safe("waveform.offset", lambda: float(q("SOUR:WAVE:OFFS?")))
            if w_offs is not None and hasattr(self, "wave_offs"):
                self.wave_offs.setValue(w_offs)

            w_phas = safe("waveform.phase", lambda: float(q("SOUR:WAVE:PHAS?")))
            if w_phas is not None and hasattr(self, "wave_phase"):
                self.wave_phase.setValue(w_phas)

            w_duty = safe("waveform.duty", lambda: float(q("SOUR:WAVE:DUTY?")))
            if w_duty is not None and hasattr(self, "wave_duty"):
                self.wave_duty.setValue(w_duty)

            # --- TRIGGER (optional widgets) ---
            t_src = safe("trigger.source", lambda: q("TRIG:SOUR?").strip())
            if t_src is not None and hasattr(self, "trig_src"):
                self.trig_src.setCurrentText(t_src)

            t_slope = safe("trigger.slope", lambda: q("TRIG:SLOP?").strip())
            if t_slope is not None and hasattr(self, "trig_slope"):
                self.trig_slope.setCurrentText(t_slope)

            t_level = safe("trigger.level", lambda: float(q("TRIG:LEV?")))
            if t_level is not None and hasattr(self, "trig_level"):
                self.trig_level.setValue(t_level)

            t_delay = safe("trigger.delay", lambda: float(q("TRIG:DEL?")))
            if t_delay is not None and hasattr(self, "trig_delay"):
                self.trig_delay.setValue(t_delay)

            t_count = safe("trigger.count", lambda: int(float(q("TRIG:COUN?"))))
            if t_count is not None and hasattr(self, "trig_count"):
                self.trig_count.setValue(t_count)

            self._append("Settings loaded from instrument")

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to load settings from instrument: {str(e)}")
            self._append(f"Error loading from instrument: {e}")

        finally:
            # restore timeout
            try:
                if old_timeout is not None and self.driver.inst is not None:
                    self.driver.inst.timeout = old_timeout
            except Exception:
                pass

            self.btn_load_from_instr.setEnabled(True)
            self.btn_load_from_instr.setText("Load from Instrument")


    def _save_settings_ui(self):
        """Open file dialog to save settings to a JSON file"""
        filename, _ = QFileDialog.getSaveFileName(
            self,
            "Save Instrument Settings",
            os.getcwd(),
            "JSON Files (*.json)"
        )
        if filename:
            if not filename.endswith('.json'):
                filename += '.json'
            settings = self.get_current_settings()
            try:
                with open(filename, 'w') as f:
                    json.dump(settings, f, indent=2)
                self._append(f"Settings saved to {filename}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to save settings: {e}")

    def _load_settings_ui(self):
        """Open file dialog to load settings from a JSON file"""
        filename, _ = QFileDialog.getOpenFileName(
            self,
            "Load Instrument Settings",
            os.getcwd(),
            "JSON Files (*.json)"
        )
        if filename:
            try:
                with open(filename, 'r') as f:
                    settings = json.load(f)
                self.apply_settings(settings)
                self._append(f"Settings loaded from {filename}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to load settings: {e}")

    def get_current_settings(self) -> dict:
        """Get current settings from the UI"""
        settings = {
            'source': {
                'level': self.src_level.value(),
                'unit': self.src_unit.currentText(),
                'compliance': self.comp_spin.value(),
                'autorange': self.autorange_chk.isChecked(),
                'polarity': self.polarity_combo.currentText(),
                'mode': self.src_mode_combo.currentText()
            },
            'waveform': {
                'type': self.wave_type.currentText(),
                'amplitude': self.wave_amp.value(),
                'frequency': self.wave_freq.value(),
                'offset': self.wave_offs.value(),
                'phase': self.wave_phase.value(),
                'duty': self.wave_duty.value()
            },
            'trigger': {
                'source': self.trig_src.currentText(),
                'slope': self.trig_slope.currentText(),
                'level': self.trig_level.value(),
                'delay': self.trig_delay.value(),
                'count': self.trig_count.value()
            }
            # Add more settings as needed
        }
        return settings

    def apply_settings(self, settings: dict, apply_to_instrument: bool = True):
        """Apply settings from a dictionary to the UI and optionally to the instrument"""
        try:
            # Apply source settings
            src = settings.get('source', {})
            self.src_level.setValue(float(src.get('level', self.src_level.value())))
            self.src_unit.setCurrentText(str(src.get('unit', self.src_unit.currentText())))
            self.comp_spin.setValue(float(src.get('compliance', self.comp_spin.value())))
            self.autorange_chk.setChecked(bool(src.get('autorange', self.autorange_chk.isChecked())))
            self.polarity_combo.setCurrentText(str(src.get('polarity', self.polarity_combo.currentText())))
            self.src_mode_combo.setCurrentText(str(src.get('mode', self.src_mode_combo.currentText())))
            
            # Apply waveform settings
            wave = settings.get('waveform', {})
            self.wave_type.setCurrentText(str(wave.get('type', self.wave_type.currentText())))
            self.wave_amp.setValue(float(wave.get('amplitude', self.wave_amp.value())))
            self.wave_freq.setValue(float(wave.get('frequency', self.wave_freq.value())))
            self.wave_offs.setValue(float(wave.get('offset', self.wave_offs.value())))
            self.wave_phase.setValue(float(wave.get('phase', self.wave_phase.value())))
            self.wave_duty.setValue(float(wave.get('duty', self.wave_duty.value())))
            
            # Apply trigger settings
            trig = settings.get('trigger', {})
            self.trig_src.setCurrentText(str(trig.get('source', self.trig_src.currentText())))
            self.trig_slope.setCurrentText(str(trig.get('slope', self.trig_slope.currentText())))
            self.trig_level.setValue(float(trig.get('level', self.trig_level.value())))
            self.trig_delay.setValue(float(trig.get('delay', self.trig_delay.value())))
            self.trig_count.setValue(int(trig.get('count', self.trig_count.value())))
            
            # Apply settings to instrument if requested
            if apply_to_instrument and self.driver.connected:
                self._apply_all_settings()
                
        except Exception as e:
            self._append(f"Error applying settings: {e}")

    def _apply_all_settings(self):
        """Apply all current UI settings to the instrument"""
        if not self.driver.connected:
            return
            
        try:
            # Apply source settings
            self._set_level()
            self._apply_comp()
            self.driver.set_range("AUTO" if self.autorange_chk.isChecked() else "OFF")
            self.driver.set_polarity(self.polarity_combo.currentText())
            self.driver.queue(f"SOUR:FUNC:MODE {self.src_mode_combo.currentText()}")
            
            # Apply waveform settings
            wave_params = {
                'type': self.wave_type.currentText(),
                'amp': self.wave_amp.value(),
                'freq': self.wave_freq.value(),
                'offset': self.wave_offs.value(),
                'phase': self.wave_phase.value(),
                'duty': self.wave_duty.value()
            }
            self.driver.configure_wave(wave_params)
            
            # Apply trigger settings
            self._apply_trigger()
            
            self._append("All settings applied to instrument")
        except Exception as e:
            self._append(f"Failed to apply settings to instrument: {e}")
    def closeEvent(self, ev):
        try:
            if hasattr(self, "sweep_worker") and self.sweep_worker and self.sweep_worker.isRunning():
                self.sweep_worker.abort()
                self.sweep_worker.wait(500)
        except Exception:
            pass
        try:
            if self._trace_stream_stop and not self._trace_stream_stop.is_set():
                self._trace_stream_stop.set()
        except Exception:
            pass
        try:
            self.driver.close()
        except Exception:
            pass
        super().closeEvent(ev)


def main():
    app = QApplication(sys.argv)
    w = FullApp()
    w.show()
    
    # Play the local MP3 file
    from PyQt5.QtCore import QTimer
    import os
    
    # Direct path to the audio file
   # audio_file = os.path.expanduser("~/Desktop/march.wav")
    #print(f"Looking for audio file at: {audio_file}")
    
    #QTimer.singleShot(500, lambda: w.play_local_audio(audio_file))
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
    
