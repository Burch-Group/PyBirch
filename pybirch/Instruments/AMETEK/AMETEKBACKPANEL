import struct
import sys
import time
import csv
import traceback
from functools import partial
from typing import Optional, Dict, Any, List
import json

from PyQt5 import QtWidgets, QtCore

# try flexible import for pymeasure Ametek driver â€” different versions may use different names
try:
    from pymeasure.instruments.ametek import Ametek7230 as _AmetekClass
except Exception:
    try:
        from pymeasure.instruments.ametek import Ametek7270 as _AmetekClass
    except Exception:
        _AmetekClass = None

try:
    from pymeasure.adapters import VISAAdapter
except Exception:
    VISAAdapter = None

# ---------------------------
# Status bit decoding (N command bits)
# ---------------------------
STATUS_BITS = {
    0: "Input overload",
    1: "Output overload",
    2: "Time constant overload",
    3: "Unlock",
    4: "Signal overload",
    5: "Frequency out of range",
    6: "Invalid command",
    7: "DSP error",
}


def decode_status(byteval: int) -> str:
    flags = []
    for bit, desc in STATUS_BITS.items():
        if byteval & (1 << bit):
            flags.append(desc)
    return ", ".join(flags) if flags else "OK"


# ST bit mapping (extended status word)
ST_BITS = {
    0: "Command NOT complete",
    1: "Invalid command",
    2: "Parameter error",
    3: "Reference unlock",
    4: "Output overload",
    5: "New ADC values available",
    6: "Input overload",
    7: "Data available",
}


def decode_st(byteval: int) -> str:
    flags = []
    for bit, desc in ST_BITS.items():
        if byteval & (1 << bit):
            flags.append(desc)
    return ", ".join(flags) if flags else "OK"


# DC channel mapping (for DC. command)
DC_CHANNELS = {
    "X (0)": 0,
    "Y (1)": 1,
    "MAG (2)": 2,
    "PHA (3)": 3,
    "X1 (4)": 4,
    "Y1 (5)": 5,
    "MAG1 (6)": 6,
    "PHA1 (7)": 7,
    "ADC1 (8)": 8,
    "ADC2 (9)": 9,
    "ADC3 (10)": 10,
    "ADC4 (11)": 11,
}

# sensible defaults for SENSITIVITIES and TIME_CONSTANTS
SENSITIVITY_DEFAULTS = [
    1e-9, 2e-9, 5e-9,
    1e-8, 2e-8, 5e-8,
    1e-7, 2e-7, 5e-7,
    1e-6, 2e-6, 5e-6,
    1e-5, 2e-5, 5e-5,
    1e-4, 2e-4, 5e-4,
    1e-3, 2e-3, 5e-3, 1e-2, 1e-1, 1.0
]
TIME_CONSTANT_DEFAULTS = [
    10e-6, 30e-6, 100e-6, 300e-6,
    1e-3, 3e-3, 10e-3, 30e-3,
    0.1, 0.3, 1.0, 3.0, 10.0, 30.0, 100.0
]


# ---------------------------
# Polling worker (sampling only)
# ---------------------------
class PollWorker(QtCore.QObject):
    measurements_ready = QtCore.pyqtSignal(dict)
    error = QtCore.pyqtSignal(Exception)
    finished = QtCore.pyqtSignal()

    def __init__(self, inst, interval_ms=500):
        super().__init__()
        self.inst = inst
        self.interval_ms = int(interval_ms)
        self._running = False

    @QtCore.pyqtSlot()
    def start(self):
        self._running = True
        try:
            while self._running:
                try:
                    payload = self._sample_once()
                    self.measurements_ready.emit(payload)
                except Exception as e:
                    self.error.emit(e)
                    break
                # responsive sleep (allow stop quickly)
                slept = 0.0
                step = 0.05
                target = self.interval_ms / 1000.0
                while slept < target and self._running:
                    time.sleep(min(step, target - slept))
                    slept += step
        finally:
            self.finished.emit()

    def _parse_float(self, s: Optional[str]) -> Optional[float]:
        if s is None:
            return None
        try:
            return float(s)
        except Exception:
            try:
                token = str(s).strip().split()[0]
                return float(token)
            except Exception:
                return None

    def _ask_float(self, cmd: str) -> Optional[float]:
        try:
            return self._parse_float(self.inst.ask(cmd))
        except Exception:
            return None

    def _ask_int(self, cmd: str, base: int = 10) -> Optional[int]:
        try:
            raw = self.inst.ask(cmd)
            if raw is None:
                return None
            return int(str(raw).strip(), base)
        except Exception:
            try:
                raw = self.inst.ask(cmd)
                if raw is None:
                    return None
                return int(str(raw).strip().split()[0], base)
            except Exception:
                return None

    def _sample_once(self) -> Dict[str, Any]:
        x = y = mag = pha = None
        # X and Y
        try:
            xv = getattr(self.inst, "x", None)
            yv = getattr(self.inst, "y", None)
            if xv is not None and yv is not None:
                x, y = xv, yv
        except Exception:
            pass
        if x is None:
            x = self._ask_float("X.")
        if y is None:
            y = self._ask_float("Y.")

        # MAG/PHASE
        try:
            mag = getattr(self.inst, "mag", None)
            pha = getattr(self.inst, "theta", None)
        except Exception:
            mag = pha = None
        if mag is None:
            mag = self._ask_float("MAG.")
        if pha is None:
            pha = self._ask_float("PHA.")

        # Harmonics
        mag1 = self._ask_float("MAG1.")
        pha1 = self._ask_float("PHA1.")
        mag2 = self._ask_float("MAG2.")
        pha2 = self._ask_float("PHA2.")

        # ADCs
        adc_vals: Dict[int, Optional[float]] = {}
        for i in range(1, 5):
            try:
                prop = getattr(self.inst, f"adc{i}", None)
                if prop is not None:
                    adc_vals[i] = float(prop)
                    continue
            except Exception:
                pass
            try:
                adc_vals[i] = self._ask_float(f"ADC. {i}")
            except Exception:
                adc_vals[i] = None

        # N and ST
        n_status = None
        try:
            n_raw = self.inst.ask("N")
            if n_raw is not None:
                try:
                    n_status = int(str(n_raw).strip())
                except Exception:
                    try:
                        n_status = int(str(n_raw).strip().split()[0])
                    except Exception:
                        n_status = None
        except Exception:
            n_status = None

        st_status_raw = None
        st_status_int = None
        try:
            st_status_raw = self.inst.ask("ST")
            if st_status_raw is not None:
                s = str(st_status_raw).strip()
                try:
                    st_status_int = int(s)
                except Exception:
                    try:
                        st_status_int = int(s, 16)
                    except Exception:
                        st_status_int = None
        except Exception:
            st_status_raw = None
            st_status_int = None

        return {
            "x": x,
            "y": y,
            "mag": mag,
            "phase": pha,
            "mag1": mag1,
            "phase1": pha1,
            "mag2": mag2,
            "phase2": pha2,
            "adc": adc_vals,
            "n_status": n_status,
            "st_status_raw": st_status_raw,
            "st_status_int": st_status_int,
        }

    def stop(self):
        self._running = False


# ---------------------------
# Worker for downloading curve buffer (runs off GUI thread)
# ---------------------------
class DownloadWorker(QtCore.QObject):
    finished = QtCore.pyqtSignal(list)
    raw_bytes = QtCore.pyqtSignal(bytes)
    error = QtCore.pyqtSignal(Exception)

    def __init__(self, inst, ch_idx: int, length: int, timeout_s: float = 10.0):
        super().__init__()
        self.inst = inst
        self.ch_idx = ch_idx
        self.length = length
        self.timeout_s = timeout_s

    @QtCore.pyqtSlot()
    def run(self):
        try:
            # try binary reads first using typical tokens
            attempts = [f"DCB {self.ch_idx}", f"DC. {self.ch_idx}", f"DCB", f"DC."]
            binary_resp = None
            for cmd in attempts:
                try:
                    # request then read bytes if resource available
                    # many drivers implement ask for binary as well; try ask first
                    resp = None
                    try:
                        resp = self.inst.ask(cmd)
                    except Exception:
                        try:
                            self.inst.write(cmd)
                        except Exception:
                            pass
                    # If resp is bytes, accept it
                    if isinstance(resp, (bytes, bytearray)):
                        binary_resp = bytes(resp)
                        break
                    # If resp is text, try parsing floats (ASCII)
                    if isinstance(resp, str):
                        s = resp.strip()
                        if s:
                            parts = s.replace(",", " ").split()
                            floats = []
                            for p in parts:
                                try:
                                    floats.append(float(p))
                                except Exception:
                                    pass
                            if floats:
                                self.finished.emit(floats)
                                return
                except Exception:
                    pass

            # If binary obtained, unpack to 16-bit signed
            if binary_resp:
                # try big-endian then little-endian
                for fmt_prefix in (">", "<"):
                    try:
                        count = len(binary_resp) // 2
                        vals = list(struct.unpack(fmt_prefix + f"{count}h", binary_resp[:count * 2]))
                        self.finished.emit(vals)
                        return
                    except Exception:
                        continue
                # no unpack -> emit raw bytes
                self.raw_bytes.emit(binary_resp)
                return

            # fallback: try segmented ASCII reads by index
            vals = []
            try:
                for i in range(self.length):
                    try:
                        r = self.inst.ask(f"DC. {self.ch_idx} {i}")
                        if r is None:
                            break
                        vals.append(float(str(r).strip()))
                    except Exception:
                        break
            except Exception:
                pass
            self.finished.emit(vals)
        except Exception as e:
            self.error.emit(e)


# ---------------------------
# Main GUI
# ---------------------------
class Ametek7230ControlWidget(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Ametek 7230 - Full Control (PyQt5) - Fixed")
        self.inst = None
        self.poll_thread: Optional[QtCore.QThread] = None
        self.poll_worker: Optional[PollWorker] = None
        self.curve_data: List[float] = []
        self._build_ui()
        self._wire_basic_signals()

    # -------------------------
    # Build UI
    # -------------------------
    def _build_ui(self):
        scroll_area = QtWidgets.QScrollArea(self)
        scroll_area.setWidgetResizable(True)

        container = QtWidgets.QWidget()
        grid = QtWidgets.QGridLayout(container)

        scroll_area.setWidget(container)
        outer_layout = QtWidgets.QVBoxLayout(self)
        outer_layout.addWidget(scroll_area)
        self.setLayout(outer_layout)

        # Connection row
        self.resource_le = QtWidgets.QLineEdit("USB0::0x0A2D::0x0027::20059235::RAW")
        self.connect_btn = QtWidgets.QPushButton("Connect")
        self.disconnect_btn = QtWidgets.QPushButton("Disconnect")
        self.disconnect_btn.setEnabled(False)
        grid.addWidget(QtWidgets.QLabel("VISA Resource:"), 0, 0)
        grid.addWidget(self.resource_le, 0, 1, 1, 3)
        grid.addWidget(self.connect_btn, 0, 4)
        grid.addWidget(self.disconnect_btn, 0, 5)

        # Status / ID
        self.id_lbl = QtWidgets.QLabel("ID: â€“")
        self.status_lbl = QtWidgets.QLabel("Status: Disconnected")
        grid.addWidget(self.id_lbl, 1, 0, 1, 3)
        grid.addWidget(self.status_lbl, 1, 3, 1, 3)

        # Input config
        in_grp = QtWidgets.QGroupBox("Input / Signal Channel")
        in_layout = QtWidgets.QFormLayout(in_grp)

        self.imode_cb = QtWidgets.QComboBox()
        self.imode_cb.addItems(
            ["Voltage (IMODE=0)", "High BW Current (IMODE=1)", "Low-Noise Current (IMODE=2)"]
        )
        in_layout.addRow("Input Mode", self.imode_cb)

        self.vmode_cb = QtWidgets.QComboBox()
        self.vmode_cb.addItems(["A (Single-Ended)", "B (Other)", "Differential (A-B)"])
        in_layout.addRow("Connector Mode", self.vmode_cb)

        self.float_chk = QtWidgets.QCheckBox("Float input connector shell")
        in_layout.addRow(self.float_chk)

        self.acgain_sb = QtWidgets.QSpinBox()
        self.acgain_sb.setRange(0, 15)
        self.acgain_sb.setSuffix(" dB")
        self.auto_acgain_chk = QtWidgets.QCheckBox("Auto AC Gain")
        in_layout.addRow("AC Gain", self.acgain_sb)
        in_layout.addRow(self.auto_acgain_chk)

        self.lf_mode_cb = QtWidgets.QComboBox()
        self.lf_mode_cb.addItems(["Off", "50/60 Hz", "100/120 Hz", "Both"])
        self.lf_freq_cb = QtWidgets.QComboBox()
        self.lf_freq_cb.addItems(["60 Hz", "50 Hz"])
        in_layout.addRow("Line Filter Mode", self.lf_mode_cb)
        in_layout.addRow("LF Center Freq", self.lf_freq_cb)

        grid.addWidget(in_grp, 2, 0, 2, 3)

        # Settings management buttons
        settings_hbox = QtWidgets.QHBoxLayout()
        self.sync_btn = QtWidgets.QPushButton("Sync from Instrument")
        self.savefile_btn = QtWidgets.QPushButton("Save Settings to File")
        self.load_btn = QtWidgets.QPushButton("Load Settings from File")
        settings_hbox.addWidget(self.sync_btn)
        settings_hbox.addWidget(self.savefile_btn)
        settings_hbox.addWidget(self.load_btn)
        grid.addLayout(settings_hbox, 5, 0, 1, 6)

        # Reference channel
        ref_grp = QtWidgets.QGroupBox("Reference / Oscillator")
        ref_layout = QtWidgets.QFormLayout(ref_grp)

        self.refmode_cb = QtWidgets.QComboBox()
        self.refmode_cb.addItems(["Single (0)", "Dual Harmonic (1)", "Dual Reference (2)"])
        ref_layout.addRow("Reference Mode", self.refmode_cb)

        self.refsrc_cb = QtWidgets.QComboBox()
        self.refsrc_cb.addItems(["Internal", "EXT TTL", "EXT Analog"])
        ref_layout.addRow("Reference Source", self.refsrc_cb)

        self.harmonic_sb = QtWidgets.QSpinBox()
        self.harmonic_sb.setRange(1, 127)
        self.phase_sb = QtWidgets.QDoubleSpinBox()
        self.phase_sb.setRange(-360, 360)
        self.phase_sb.setDecimals(3)
        ref_layout.addRow("Harmonic", self.harmonic_sb)
        ref_layout.addRow("Phase (deg)", self.phase_sb)

        self.auto_phase_btn = QtWidgets.QPushButton("Auto-Phase (AQN)")
        ref_layout.addRow(self.auto_phase_btn)

        self.osc_amp_sb = QtWidgets.QDoubleSpinBox()
        self.osc_amp_sb.setRange(0, 5)
        self.osc_amp_sb.setDecimals(6)
        self.osc_freq_sb = QtWidgets.QDoubleSpinBox()
        self.osc_freq_sb.setRange(0, 250000)
        self.osc_freq_sb.setDecimals(3)
        ref_layout.addRow("Osc Amp (V)", self.osc_amp_sb)
        ref_layout.addRow("Osc Freq (Hz)", self.osc_freq_sb)

        grid.addWidget(ref_grp, 2, 3, 2, 3)

        # Outputs / sensitivity / extras
        out_grp = QtWidgets.QGroupBox("Outputs / Sensitivity / Extras")
        out_layout = QtWidgets.QFormLayout(out_grp)

        self.sensitivity_cb = QtWidgets.QComboBox()
        out_layout.addRow("Sensitivity", self.sensitivity_cb)

        hbox = QtWidgets.QHBoxLayout()
        self.auto_sens_btn = QtWidgets.QPushButton("Auto-Sensitivity (AS)")
        self.auto_measure_btn = QtWidgets.QPushButton("Auto-Measure (ASM)")
        self.asm_chan_cb = QtWidgets.QComboBox()
        self.asm_chan_cb.addItems(["Chan 1", "Chan 2"])
        hbox.addWidget(self.auto_sens_btn)
        hbox.addWidget(self.auto_measure_btn)
        hbox.addWidget(self.asm_chan_cb)
        out_layout.addRow(hbox)

        self.tc_cb = QtWidgets.QComboBox()
        self.slope_cb = QtWidgets.QComboBox()
        self.slope_cb.addItems(["6", "12", "18", "24"])
        out_layout.addRow("Time Constant", self.tc_cb)
        out_layout.addRow("Slope", self.slope_cb)

        self.sync_tc_chk = QtWidgets.QCheckBox("Synchronous TC")
        out_layout.addRow(self.sync_tc_chk)

        self.reserve_mode_cb = QtWidgets.QComboBox()
        self.reserve_mode_cb.addItems(["High Reserve", "Low Noise", "Wideband"])
        out_layout.addRow("Reserve Mode (preset)", self.reserve_mode_cb)
        self.dynamic_reserve_chk = QtWidgets.QCheckBox("Auto AC Gain (approx DR)")
        out_layout.addRow(self.dynamic_reserve_chk)

        extra_hbox = QtWidgets.QHBoxLayout()
        self.ar_btn = QtWidgets.QPushButton("Auto-Reserve (AR)")
        self.atc_btn = QtWidgets.QPushButton("Auto-TC (ATC)")
        self.noise_btn = QtWidgets.QPushButton("Toggle Noise Mode")
        self.rtoa_btn = QtWidgets.QPushButton("Ratio->A (RTOA)")
        self.rto_b_btn = QtWidgets.QPushButton("Ratio->B (RTOB)")
        extra_hbox.addWidget(self.ar_btn)
        extra_hbox.addWidget(self.atc_btn)
        extra_hbox.addWidget(self.noise_btn)
        extra_hbox.addWidget(self.rtoa_btn)
        extra_hbox.addWidget(self.rto_b_btn)
        out_layout.addRow(extra_hbox)

        sr_hbox = QtWidgets.QHBoxLayout()
        self.save_spin = QtWidgets.QSpinBox()
        self.save_spin.setRange(0, 9)
        self.save_btn = QtWidgets.QPushButton("Save (SAV n)")
        self.recall_btn = QtWidgets.QPushButton("Recall (RCL n)")
        self.reset_btn = QtWidgets.QPushButton("Reset Defaults (RST)")
        sr_hbox.addWidget(QtWidgets.QLabel("Slot"))
        sr_hbox.addWidget(self.save_spin)
        sr_hbox.addWidget(self.save_btn)
        sr_hbox.addWidget(self.recall_btn)
        sr_hbox.addWidget(self.reset_btn)
        out_layout.addRow(sr_hbox)

        grid.addWidget(out_grp, 4, 0, 2, 3)

        # DACs + ADCs + Offsets
        io_grp = QtWidgets.QGroupBox("DAC / ADC / Offsets")
        io_layout = QtWidgets.QGridLayout(io_grp)

        self.dac_sbs = []
        for i in range(1, 5):
            sb = QtWidgets.QDoubleSpinBox()
            sb.setRange(-10, 10)
            sb.setDecimals(6)
            io_layout.addWidget(QtWidgets.QLabel(f"DAC{i}"), 0, (i - 1) * 2)
            io_layout.addWidget(sb, 0, (i - 1) * 2 + 1)
            self.dac_sbs.append(sb)

        self.adc_lbls = []
        for i in range(1, 5):
            lbl = QtWidgets.QLabel(f"ADC{i}: â€“")
            io_layout.addWidget(lbl, 1, i - 1)
            self.adc_lbls.append(lbl)

        self.offsets_btn = QtWidgets.QPushButton("Auto Offsets (AXO)")
        io_layout.addWidget(self.offsets_btn, 2, 0, 1, 2)

        grid.addWidget(io_grp, 4, 3, 2, 3)

        # Measurements
        meas_grp = QtWidgets.QGroupBox("Measurements")
        meas_layout = QtWidgets.QGridLayout(meas_grp)

        self.x_lbl = QtWidgets.QLabel("X: â€“")
        self.y_lbl = QtWidgets.QLabel("Y: â€“")
        self.mag_lbl = QtWidgets.QLabel("Mag: â€“")
        self.phase_lbl = QtWidgets.QLabel("Phase: â€“")
        self.mag1_lbl = QtWidgets.QLabel("Mag1: â€“")
        self.phase1_lbl = QtWidgets.QLabel("Phase1: â€“")
        self.mag2_lbl = QtWidgets.QLabel("Mag2: â€“")
        self.phase2_lbl = QtWidgets.QLabel("Phase2: â€“")

        meas_layout.addWidget(self.x_lbl, 0, 0)
        meas_layout.addWidget(self.y_lbl, 0, 1)
        meas_layout.addWidget(self.mag_lbl, 1, 0)
        meas_layout.addWidget(self.phase_lbl, 1, 1)
        meas_layout.addWidget(self.mag1_lbl, 2, 0)
        meas_layout.addWidget(self.phase1_lbl, 2, 1)
        meas_layout.addWidget(self.mag2_lbl, 3, 0)
        meas_layout.addWidget(self.phase2_lbl, 3, 1)

        grid.addWidget(meas_grp, 6, 0, 2, 3)

        # Curve buffer panel
        curve_grp = QtWidgets.QGroupBox("Curve Buffer")
        curve_layout = QtWidgets.QVBoxLayout(curve_grp)

        cb_hbox = QtWidgets.QHBoxLayout()
        self.len_spin = QtWidgets.QSpinBox()
        self.len_spin.setRange(1, 1000000)
        self.len_spin.setValue(1024)
        self.curve_chan_cb = QtWidgets.QComboBox()
        self.curve_chan_cb.addItems(list(DC_CHANNELS.keys()))
        self.len_btn = QtWidgets.QPushButton("Set LEN")
        self.cbd_btn = QtWidgets.QPushButton("Start Capture (CBD)")
        self.download_btn = QtWidgets.QPushButton("Download Buffer (DC.)")
        self.export_btn = QtWidgets.QPushButton("Export CSV")
        cb_hbox.addWidget(QtWidgets.QLabel("Length"))
        cb_hbox.addWidget(self.len_spin)
        cb_hbox.addWidget(QtWidgets.QLabel("Channel"))
        cb_hbox.addWidget(self.curve_chan_cb)
        cb_hbox.addWidget(self.len_btn)
        cb_hbox.addWidget(self.cbd_btn)
        cb_hbox.addWidget(self.download_btn)
        cb_hbox.addWidget(self.export_btn)
        curve_layout.addLayout(cb_hbox)

        self.curve_table = QtWidgets.QTableWidget(0, 2)
        self.curve_table.setHorizontalHeaderLabels(["Index", "Value"])
        curve_layout.addWidget(self.curve_table)

        grid.addWidget(curve_grp, 6, 3, 4, 3)

        # Status / errors
        stat_grp = QtWidgets.QGroupBox("Status / Errors")
        stat_layout = QtWidgets.QVBoxLayout(stat_grp)
        self.overload_lbl = QtWidgets.QLabel("Overload/Status: â€“")
        self.n_status_lbl = QtWidgets.QLabel("N (decoded): â€“")
        self.st_lbl = QtWidgets.QLabel("ST (decoded/raw): â€“")
        self.err_btn = QtWidgets.QPushButton("Query ERR?")
        self.err_lbl = QtWidgets.QLabel("Last ERR?: â€“")
        stat_layout.addWidget(self.overload_lbl)
        stat_layout.addWidget(self.n_status_lbl)
        stat_layout.addWidget(self.st_lbl)
        stat_layout.addWidget(self.err_btn)
        stat_layout.addWidget(self.err_lbl)
        grid.addWidget(stat_grp, 10, 0, 2, 3)

        # Raw command
        raw_grp = QtWidgets.QGroupBox("Raw Command")
        raw_layout = QtWidgets.QVBoxLayout(raw_grp)
        self.cmd_le = QtWidgets.QLineEdit()
        self.cmd_send_btn = QtWidgets.QPushButton("Send")
        self.cmd_resp_te = QtWidgets.QPlainTextEdit()
        self.cmd_resp_te.setReadOnly(True)
        raw_hbox = QtWidgets.QHBoxLayout()
        raw_hbox.addWidget(self.cmd_le)
        raw_hbox.addWidget(self.cmd_send_btn)
        raw_layout.addLayout(raw_hbox)
        raw_layout.addWidget(self.cmd_resp_te)
        grid.addWidget(raw_grp, 12, 0, 2, 6)

        grid.setRowStretch(14, 1)

        # Populate sensitivity/time-constant defaults immediately
        self._populate_defaults_in_ui()

    # -------------------------
    # Ensure defaults exist on startup
    # -------------------------
    def _populate_defaults_in_ui(self):
        self.sensitivity_cb.clear()
        for s in SENSITIVITY_DEFAULTS:
            self.sensitivity_cb.addItem(f"{s:.6g}")
        self.tc_cb.clear()
        for t in TIME_CONSTANT_DEFAULTS:
            self.tc_cb.addItem(f"{t:.6g}")

    # -------------------------
    # Wire signals
    # -------------------------
    def _wire_basic_signals(self):
        self.connect_btn.clicked.connect(self.on_connect)
        self.disconnect_btn.clicked.connect(self.on_disconnect)
        self.cmd_send_btn.clicked.connect(self.send_raw_command)
        self.auto_phase_btn.clicked.connect(self.on_auto_phase)
        self.auto_sens_btn.clicked.connect(self.on_auto_sensitivity)
        self.auto_measure_btn.clicked.connect(self.on_auto_measure)
        self.offsets_btn.clicked.connect(self.on_offsets)
        self.err_btn.clicked.connect(self.on_err_query)
        self.len_btn.clicked.connect(lambda: self.send_cmd(f"LEN {int(self.len_spin.value())}", read=False))
        self.cbd_btn.clicked.connect(lambda: self.send_cmd("CBD 1", read=False))
        self.download_btn.clicked.connect(lambda: self._on_download_curve_clicked())
        self.auto_phase_btn.clicked.connect(lambda: self.send_cmd("AQN", read=False))  # auto-phase example

        # Curve buffer
        self.len_btn.clicked.connect(self.on_set_len)
        self.cbd_btn.clicked.connect(self.on_cbd_start)
        self.download_btn.clicked.connect(self.on_download_buffer)
        self.export_btn.clicked.connect(self.on_export_curve_csv)

        # Basic mappings
        self.sensitivity_cb.currentIndexChanged.connect(self.on_sensitivity_changed)
        self.tc_cb.currentIndexChanged.connect(self.on_tc_changed)
        self.slope_cb.currentIndexChanged.connect(self.on_slope_changed)
        self.imode_cb.currentIndexChanged.connect(self.on_imode_changed)
        self.vmode_cb.currentIndexChanged.connect(self.on_vmode_changed)
        self.float_chk.stateChanged.connect(self.on_float_toggled)
        self.lf_mode_cb.currentIndexChanged.connect(self.on_lf_changed)
        self.lf_freq_cb.currentIndexChanged.connect(self.on_lf_changed)
        self.auto_acgain_chk.stateChanged.connect(self.on_auto_acgain_toggled)
        self.osc_amp_sb.valueChanged.connect(self.on_osc_amp_changed)
        self.osc_freq_sb.valueChanged.connect(self.on_osc_freq_changed)
        self.refsrc_cb.currentIndexChanged.connect(self.on_refsrc_changed)
        self.harmonic_sb.valueChanged.connect(self.on_refn_changed)
        self.phase_sb.valueChanged.connect(self.on_refp_changed)

        # Reserve / dynamic reserve
        self.reserve_mode_cb.currentIndexChanged.connect(self.on_reserve_mode_changed)
        self.dynamic_reserve_chk.stateChanged.connect(self.on_dynamic_reserve_changed)

        # extras
        self.ar_btn.clicked.connect(lambda: self._auto_with_resync("AR", "Auto-Reserve (AR)"))
        self.atc_btn.clicked.connect(lambda: self._auto_with_resync("ATC", "Auto-TC (ATC)"))
        self.noise_btn.clicked.connect(self.on_toggle_noise)
        self.rtoa_btn.clicked.connect(lambda: self._send_raw_with_feedback("RTOA"))
        self.rto_b_btn.clicked.connect(lambda: self._send_raw_with_feedback("RTOB"))

        self.save_btn.clicked.connect(self.on_save_slot)
        self.recall_btn.clicked.connect(self.on_recall_slot)
        self.reset_btn.clicked.connect(lambda: self._send_raw_with_feedback("RST"))

        # Settings management
        self.sync_btn.clicked.connect(self.on_sync_from_inst)
        self.savefile_btn.clicked.connect(self.on_save_settings)
        self.load_btn.clicked.connect(self.on_load_settings)

        for i, sb in enumerate(self.dac_sbs, 1):
            sb.valueChanged.connect(partial(self._on_dac_set, i))

    # -------------------------
    # Connection / sync
    # -------------------------
    def on_connect(self):
        resource = self.resource_le.text().strip()
        if not resource:
            QtWidgets.QMessageBox.warning(self, "Resource", "Enter VISA resource string.")
            return
        if VISAAdapter is None or _AmetekClass is None:
            QtWidgets.QMessageBox.critical(self, "Missing dependencies", "pymeasure or VISAAdapter not available in this environment.")
            return
        try:
            adapter = VISAAdapter(resource)
            try:
                adapter.timeout = 0.5
            except Exception:
                pass
            inst = _AmetekClass(adapter)
            self.inst = inst
            try:
                self.id_lbl.setText("ID: " + str(self.inst.id))
            except Exception:
                self.id_lbl.setText("ID: connected")
            self.status_lbl.setText("Status: Connected")
            self.connect_btn.setEnabled(False)
            self.disconnect_btn.setEnabled(True)
            self._populate_after_connect()
            self._initial_sync()
            self.start_polling()
        except Exception as e:
            traceback.print_exc()
            QtWidgets.QMessageBox.critical(self, "Connect Error", f"Could not connect:{e}")

    def _populate_after_connect(self):
        if not self.inst:
            return
        try:
            sens_list = getattr(self.inst, "SENSITIVITIES", None) or SENSITIVITY_DEFAULTS
            self.sensitivity_cb.clear()
            for s in sens_list:
                self.sensitivity_cb.addItem(f"{s:.6g}")

            tc_list = getattr(self.inst, "TIME_CONSTANTS", None) or TIME_CONSTANT_DEFAULTS
            self.tc_cb.clear()
            for t in tc_list:
                self.tc_cb.addItem(f"{t:.6g}")
        except Exception:
            # leave default lists intact
            pass

    def _initial_sync(self):
        if not self.inst:
            return
        # Sensitivity
        try:
            cur_sen = None
            try:
                cur_sen = self.inst.sensitivity
            except Exception:
                try:
                    cur_sen = float(self.inst.ask("SEN?"))
                except Exception:
                    cur_sen = None
            if cur_sen is not None:
                s_list = []
                try:
                    # pull from UI list to ensure we match what is shown
                    s_list = [float(self.sensitivity_cb.itemText(i)) for i in range(self.sensitivity_cb.count())]
                except Exception:
                    s_list = getattr(self.inst, "SENSITIVITIES", SENSITIVITY_DEFAULTS)
                if s_list:
                    try:
                        idx = min(range(len(s_list)), key=lambda i: abs(s_list[i] - float(cur_sen)))
                        self.sensitivity_cb.setCurrentIndex(idx)
                    except Exception:
                        pass
        except Exception:
            pass

        # Time constant
        try:
            cur_tc = None
            try:
                cur_tc = self.inst.time_constant
            except Exception:
                try:
                    cur_tc = float(self.inst.ask("TC?"))
                except Exception:
                    cur_tc = None
            if cur_tc is not None:
                tc_list = []
                try:
                    tc_list = [float(self.tc_cb.itemText(i)) for i in range(self.tc_cb.count())]
                except Exception:
                    tc_list = getattr(self.inst, "TIME_CONSTANTS", TIME_CONSTANT_DEFAULTS)
                if tc_list:
                    try:
                        idx = min(range(len(tc_list)), key=lambda i: abs(tc_list[i] - float(cur_tc)))
                        self.tc_cb.setCurrentIndex(idx)
                    except Exception:
                        pass
        except Exception:
            pass

        # Slope
        try:
            try:
                cur_slope = self.inst.slope
            except Exception:
                try:
                    cur_slope = int(self.inst.ask("SLOPE?"))
                except Exception:
                    cur_slope = None
            if cur_slope is not None:
                idx = {6: 0, 12: 1, 18: 2, 24: 3}.get(int(cur_slope), 0)
                self.slope_cb.setCurrentIndex(idx)
        except Exception:
            pass

        # Reference harmonic and phase
        try:
            try:
                cur_refn = self.inst.harmonic
                if cur_refn is not None:
                    self.harmonic_sb.setValue(int(cur_refn))
            except Exception:
                pass
            try:
                cur_refp = self.inst.phase
                if cur_refp is not None:
                    self.phase_sb.setValue(float(cur_refp))
            except Exception:
                pass
        except Exception:
            pass

        # Oscillator amplitude/freq
        try:
            try:
                cur_oa = None
                try:
                    cur_oa = self.inst.voltage
                except Exception:
                    cur_oa = self.inst.ask("OA.?") if hasattr(self.inst, 'ask') else None
                if cur_oa is not None:
                    self.osc_amp_sb.setValue(float(cur_oa))
            except Exception:
                pass
            try:
                cur_of = None
                try:
                    cur_of = self.inst.frequency
                except Exception:
                    cur_of = self.inst.ask("OF.?") if hasattr(self.inst, 'ask') else None
                if cur_of is not None:
                    self.osc_freq_sb.setValue(float(cur_of))
            except Exception:
                pass
        except Exception:
            pass

        # AUTOMATIC (auto gain)
        try:
            try:
                auto_gain = getattr(self.inst, "auto_gain", None)
                if auto_gain is not None:
                    self.auto_acgain_chk.setChecked(bool(auto_gain))
                else:
                    # fallback query
                    try:
                        ag = self.inst.ask("AUTOMATIC?")
                        if str(ag).strip() in ("1", "ON", "+1"):
                            self.auto_acgain_chk.setChecked(True)
                    except Exception:
                        pass
            except Exception:
                pass
        except Exception:
            pass

        # IMODE
        try:
            try:
                cur_imode = int(self.inst.ask("IMODE"))
            except Exception:
                cur_imode = None
            if cur_imode is not None and cur_imode in (0, 1, 2):
                self.imode_cb.setCurrentIndex(cur_imode)
        except Exception:
            pass

        # VMODE
        try:
            try:
                cur_vmode = int(self.inst.ask("VMODE"))
            except Exception:
                cur_vmode = None
            if cur_vmode is not None:
                if cur_vmode == 1:
                    self.vmode_cb.setCurrentIndex(0)
                elif cur_vmode == 2:
                    self.vmode_cb.setCurrentIndex(1)
                elif cur_vmode == 3:
                    self.vmode_cb.setCurrentIndex(2)
        except Exception:
            pass

        # LF (n1 n2)
        try:
            try:
                lf_resp = str(self.inst.ask("LF") or "").strip()
                parts = lf_resp.replace(",", " ").split()
                if len(parts) >= 2:
                    n1 = int(parts[0]); n2 = int(parts[1])
                    if 0 <= n1 <= 3:
                        self.lf_mode_cb.setCurrentIndex(n1)
                    if 0 <= n2 <= 1:
                        self.lf_freq_cb.setCurrentIndex(n2)
            except Exception:
                pass
        except Exception:
            pass

        # Reference source IE
        try:
            try:
                cur_ie = int(self.inst.ask("IE"))
            except Exception:
                cur_ie = None
            if cur_ie is not None and 0 <= cur_ie <= (self.refsrc_cb.count() - 1):
                self.refsrc_cb.setCurrentIndex(cur_ie)
        except Exception:
            pass

        # DACs 1-4
        for i in range(1, 5):
            try:
                val = None
                try:
                    val = float(self.inst.ask(f"DAC. {i}"))
                except Exception:
                    try:
                        val = float(getattr(self.inst, f"dac{i}"))
                    except Exception:
                        pass
                if val is not None:
                    try:
                        self.dac_sbs[i-1].blockSignals(True)
                        self.dac_sbs[i-1].setValue(val)
                        self.dac_sbs[i-1].blockSignals(False)
                    except Exception:
                        pass
            except Exception:
                pass

        # best-effort ST/N update for UI
        try:
            try:
                n_raw = self.inst.ask("N")
                try:
                    n_val = int(n_raw)
                    self.n_status_lbl.setText(f"N (decoded): {decode_status(n_val)} ({n_val})")
                    self.overload_lbl.setText(f"Overload/Status: {decode_status(n_val)}")
                except Exception:
                    self.n_status_lbl.setText(f"N (raw): {n_raw}")
            except Exception:
                pass
            try:
                st_raw = self.inst.ask("ST")
                try:
                    st_int = int(st_raw)
                    self.st_lbl.setText(f"ST (decoded): {decode_st(st_int)} ({st_int})")
                except Exception:
                    try:
                        st_int = int(st_raw, 16)
                        self.st_lbl.setText(f"ST (decoded): {decode_st(st_int)} ({st_raw})")
                    except Exception:
                        self.st_lbl.setText(f"ST (raw): {st_raw}")
            except Exception:
                pass
        except Exception:
            pass
    def on_sync_from_inst(self):
        if not self.inst:
            QtWidgets.QMessageBox.warning(self, "No Instrument", "Connect first.")
            return
        try:
            self._initial_sync()
            QtWidgets.QMessageBox.information(self, "Sync Complete", "Synchronized settings from instrument.")
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Sync Error", str(e))

    def on_disconnect(self):
        self.stop_polling()
        if self.inst:
            try:
                self.inst.shutdown()
            except Exception:
                pass
        self.inst = None
        self.status_lbl.setText("Status: Disconnected")
        self.connect_btn.setEnabled(True)
        self.disconnect_btn.setEnabled(False)
        self.id_lbl.setText("ID: â€“")

    # -------------------------
    # Polling control
    # -------------------------
    def start_polling(self, interval_ms=500):
        if not self.inst:
            return
        self.stop_polling()
        self.poll_worker = PollWorker(self.inst, interval_ms=interval_ms)
        self.poll_thread = QtCore.QThread()
        self.poll_worker.moveToThread(self.poll_thread)
        self.poll_thread.started.connect(self.poll_worker.start)
        self.poll_worker.measurements_ready.connect(self._on_measurements)
        self.poll_worker.error.connect(self._on_poll_error)
        self.poll_worker.finished.connect(self.poll_thread.quit)
        self.poll_worker.finished.connect(self.poll_worker.deleteLater)
        self.poll_thread.finished.connect(self.poll_thread.deleteLater)
        self.poll_thread.start()

    def stop_polling(self):
        if self.poll_worker:
            try:
                self.poll_worker.stop()
            except Exception:
                pass
            self.poll_worker = None
        if self.poll_thread:
            try:
                self.poll_thread.quit()
                self.poll_thread.wait(1500)
            except Exception:
                pass
            self.poll_thread = None
    def _read_exact_bytes(self, expected_bytes: int, timeout_s: float):
        adapter = getattr(self.inst, "adapter", None)
        resource = getattr(adapter, "resource", None) if adapter else None
        if resource is None:
            # try driver-level methods
            if hasattr(self.inst, "read_bytes"):
                return self.inst.read_bytes(expected_bytes)
            raise RuntimeError("Raw resource not available for binary read")
        old_timeout = None
        try:
            if hasattr(resource, "timeout"):
                old_timeout = resource.timeout
                resource.timeout = int(timeout_s * 1000)
            buf = bytearray()
            start = time.time()
            while len(buf) < expected_bytes and (time.time() - start) < timeout_s:
                # use read_bytes when available
                if hasattr(resource, "read_bytes"):
                    chunk = resource.read_bytes(expected_bytes - len(buf))
                else:
                    # generic read() fallback
                    chunk = resource.read(expected_bytes - len(buf))
                if not chunk:
                    # small sleep to allow device to send
                    time.sleep(0.05)
                    continue
                if isinstance(chunk, str):
                    chunk = chunk.encode("latin1")
                buf.extend(chunk)
            if len(buf) != expected_bytes:
                raise IOError(f"Expected {expected_bytes} bytes, got {len(buf)}")
            return bytes(buf)
        finally:
            try:
                if old_timeout is not None:
                    resource.timeout = old_timeout
            except Exception:
                pass

    # get ASCII delimiter (DD) and USB terminator (USBTERM)
    def get_delimiter(self) -> str:
        try:
            resp = self.inst.ask("DD")
            if resp is None:
                return ","
            s = str(resp).strip()
            # numeric ASCII code
            if s.isdigit():
                ch = int(s)
                return chr(ch)
            return s[0] if s else ","
        except Exception:
            return ","

    def get_usb_terminator(self) -> bytes:
        try:
            resp = self.inst.ask("USBTERM")
            if resp is None:
                return b"\n"
            s = str(resp).strip()
            if s == "0":  # null-only
                return b"\x00"
            if s == "1":  # null+status+overload
                return b"\x00"
            return b"\n"
        except Exception:
            return b"\n"

    # ensure CBD includes SEN bit (bit 4 single ref, bit 21 dual modes)
    def ensure_sen_in_cbd(self):
        try:
            cbd_resp = self.inst.ask("CBD")
            if cbd_resp is None:
                return
            cbd_val = int(str(cbd_resp).strip())
            # bit 4 -> value 16, bit21 -> 2097152; set bit4 at minimum
            if not (cbd_val & 16):
                new = cbd_val | 16
                self.inst.write(f"CBD {new}")
                # confirm
                _ = self.inst.ask("CBD")
        except Exception:
            pass
    def on_sync_from_inst(self):
        if not self.inst:
            QtWidgets.QMessageBox.warning(self, "No Instrument", "Connect first.")
            return
        try:
            self._initial_sync()
            QtWidgets.QMessageBox.information(self, "Sync Complete", "Synchronized settings from instrument.")
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Sync Error", str(e))


    def on_save_settings(self):
        options = QtWidgets.QFileDialog.Options()
        result = QtWidgets.QFileDialog.getSaveFileName(self, "Save Settings", "ametek_settings.json", "JSON Files (*.json);;All Files (*)", options=options)
        if isinstance(result, tuple):
            fname = result[0]
        else:
            fname = result
        if not fname:
            return
        settings = {
            "resource": self.resource_le.text(),
            "sensitivity_idx": self.sensitivity_cb.currentIndex(),
            "sensitivity_list": [self.sensitivity_cb.itemText(i) for i in range(self.sensitivity_cb.count())],
            "tc_idx": self.tc_cb.currentIndex(),
            "tc_list": [self.tc_cb.itemText(i) for i in range(self.tc_cb.count())],
            "slope_idx": self.slope_cb.currentIndex(),
            "imode_idx": self.imode_cb.currentIndex(),
            "vmode_idx": self.vmode_cb.currentIndex(),
            "float_input": bool(self.float_chk.isChecked()),
            "auto_acgain": bool(self.auto_acgain_chk.isChecked()),
            "lf_mode": self.lf_mode_cb.currentIndex(),
            "lf_freq": self.lf_freq_cb.currentIndex(),
            "harmonic": int(self.harmonic_sb.value()),
            "phase": float(self.phase_sb.value()),
            "osc_amp": float(self.osc_amp_sb.value()),
            "osc_freq": float(self.osc_freq_sb.value()),
            "dac": [float(sb.value()) for sb in self.dac_sbs],
            "len": int(self.len_spin.value()),
            "curve_chan": self.curve_chan_cb.currentText(),
            "reserve_mode_idx": self.reserve_mode_cb.currentIndex(),
            "dynamic_reserve": bool(self.dynamic_reserve_chk.isChecked()),
            "save_slot": int(self.save_spin.value())
        }
        try:
            import json
            with open(fname, "w", encoding="utf-8") as f:
                json.dump(settings, f, indent=2)
            QtWidgets.QMessageBox.information(self, "Saved", f"Settings saved to {fname}")
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Save Error", str(e))


    def on_load_settings(self):
        options = QtWidgets.QFileDialog.Options()
        result = QtWidgets.QFileDialog.getOpenFileName(self, "Load Settings", "", "JSON Files (*.json);;All Files (*)", options=options)
        if isinstance(result, tuple):
            fname = result[0]
        else:
            fname = result
        if not fname:
            return
        try:
            import json
            with open(fname, "r", encoding="utf-8") as f:
                settings = json.load(f)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Load Error", str(e))
            return

        try:
            self.resource_le.setText(settings.get("resource", self.resource_le.text()))

            si = settings.get("sensitivity_list")
            if si:
                self.sensitivity_cb.clear()
                for it in si:
                    self.sensitivity_cb.addItem(it)
            if "sensitivity_idx" in settings:
                idx = int(settings["sensitivity_idx"])
                if 0 <= idx < self.sensitivity_cb.count():
                    self.sensitivity_cb.setCurrentIndex(idx)

            tcl = settings.get("tc_list")
            if tcl:
                self.tc_cb.clear()
                for it in tcl:
                    self.tc_cb.addItem(it)
            if "tc_idx" in settings:
                idx = int(settings["tc_idx"])
                if 0 <= idx < self.tc_cb.count():
                    self.tc_cb.setCurrentIndex(idx)

            if "slope_idx" in settings:
                idx = int(settings["slope_idx"])
                if 0 <= idx < self.slope_cb.count():
                    self.slope_cb.setCurrentIndex(idx)

            if "imode_idx" in settings:
                idx = int(settings["imode_idx"])
                if 0 <= idx < self.imode_cb.count():
                    self.imode_cb.setCurrentIndex(idx)

            if "vmode_idx" in settings:
                idx = int(settings["vmode_idx"])
                if 0 <= idx < self.vmode_cb.count():
                    self.vmode_cb.setCurrentIndex(idx)

            if "float_input" in settings:
                self.float_chk.setChecked(bool(settings["float_input"]))
            if "auto_acgain" in settings:
                self.auto_acgain_chk.setChecked(bool(settings["auto_acgain"]))
            if "lf_mode" in settings:
                self.lf_mode_cb.setCurrentIndex(int(settings["lf_mode"]))
            if "lf_freq" in settings:
                self.lf_freq_cb.setCurrentIndex(int(settings["lf_freq"]))

            if "harmonic" in settings:
                self.harmonic_sb.setValue(int(settings["harmonic"]))
            if "phase" in settings:
                self.phase_sb.setValue(float(settings["phase"]))
            if "osc_amp" in settings:
                self.osc_amp_sb.setValue(float(settings["osc_amp"]))
            if "osc_freq" in settings:
                self.osc_freq_sb.setValue(float(settings["osc_freq"]))

            dac_vals = settings.get("dac")
            if isinstance(dac_vals, (list, tuple)):
                for i, v in enumerate(dac_vals):
                    if i < len(self.dac_sbs):
                        self.dac_sbs[i].setValue(float(v))

            if "len" in settings:
                self.len_spin.setValue(int(settings["len"]))
            if "curve_chan" in settings:
                text = settings["curve_chan"]
                idx = self.curve_chan_cb.findText(text)
                if idx >= 0:
                    self.curve_chan_cb.setCurrentIndex(idx)
            if "reserve_mode_idx" in settings:
                idx = int(settings["reserve_mode_idx"])
                if 0 <= idx < self.reserve_mode_cb.count():
                    self.reserve_mode_cb.setCurrentIndex(idx)
            if "dynamic_reserve" in settings:
                self.dynamic_reserve_chk.setChecked(bool(settings["dynamic_reserve"]))
            if "save_slot" in settings:
                self.save_spin.setValue(int(settings["save_slot"]))

            # Apply a few instrument commands if connected, using existing handlers where helpful
            if self.inst:
                try:
                    # using combobox handlers keeps behavior consistent
                    if "imode_idx" in settings:
                        self.on_imode_changed(self.imode_cb.currentIndex())
                    if "vmode_idx" in settings:
                        self.on_vmode_changed(self.vmode_cb.currentIndex())
                    if "sensitivity_idx" in settings:
                        self.on_sensitivity_changed(self.sensitivity_cb.currentIndex())
                    if "tc_idx" in settings:
                        self.on_tc_changed(self.tc_cb.currentIndex())
                    if "slope_idx" in settings:
                        self.on_slope_changed(self.slope_cb.currentIndex())
                    for i, sb in enumerate(self.dac_sbs, 1):
                        try:
                            self.send_cmd(f"DAC. {i} {float(sb.value())}", read=False)
                        except Exception:
                            pass
                    self.send_cmd(f"LEN {int(self.len_spin.value())}", read=False)
                except Exception:
                    pass

            QtWidgets.QMessageBox.information(self, "Loaded", f"Settings loaded from {fname}")
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Apply Error", str(e))

    # -------------------------
    # Measurement updates
    # -------------------------
    def on_dynamic_reserve_changed(self, state: int):
        if not self.inst:
            return
        try:
            n = 1 if state else 0
            self.send_cmd(f"DYN {n}", read=False)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Dynamic Reserve Error", str(e))

    def on_reserve_mode_changed(self, idx: int):
        if not self.inst:
            return
        try:
            mode_map = {0: "0", 1: "1", 2: "2"}
            if idx in mode_map:
                self.send_cmd(f"RMOD {mode_map[idx]}", read=False)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Reserve Mode Error", str(e))

    @QtCore.pyqtSlot(dict)
    def _on_measurements(self, data):
        try:
            self.x_lbl.setText(f"X: {data['x']:.6g}" if data["x"] is not None else "X: â€“")
            self.y_lbl.setText(f"Y: {data['y']:.6g}" if data["y"] is not None else "Y: â€“")
            self.mag_lbl.setText(f"Mag: {data['mag']:.6g}" if data["mag"] is not None else "Mag: â€“")
            self.phase_lbl.setText(f"Phase: {data['phase']:.3f}" if data["phase"] is not None else "Phase: â€“")
            self.mag1_lbl.setText(f"Mag1: {data['mag1']:.6g}" if data["mag1"] is not None else "Mag1: â€“")
            self.phase1_lbl.setText(f"Phase1: {data['phase1']:.3f}" if data["phase1"] is not None else "Phase1: â€“")
            self.mag2_lbl.setText(f"Mag2: {data['mag2']:.6g}" if data["mag2"] is not None else "Mag2: â€“")
            self.phase2_lbl.setText(f"Phase2: {data['phase2']:.3f}" if data["phase2"] is not None else "Phase2: â€“")
            for i in range(1, 5):
                val = data["adc"].get(i)
                self.adc_lbls[i - 1].setText(f"ADC{i}: {val:.6g}" if val is not None else f"ADC{i}: â€“")
            n_status = data.get("n_status")
            st_int = data.get("st_status_int")
            st_raw = data.get("st_status_raw")
            if n_status is not None:
                self.n_status_lbl.setText(f"N (decoded): {decode_status(n_status)} ({n_status})")
                self.overload_lbl.setText(f"Overload/Status: {decode_status(n_status)}")
            else:
                self.n_status_lbl.setText("N (decoded): â€“")
            if st_int is not None:
                self.st_lbl.setText(f"ST (decoded): {decode_st(st_int)} ({st_int})")
            else:
                self.st_lbl.setText(f"ST (raw): {st_raw if st_raw else 'â€“'}")
        except Exception:
            pass

    @QtCore.pyqtSlot(Exception)
    def _on_poll_error(self, exc):
        self.stop_polling()
        self.status_lbl.setText("Status: Polling Error")
        QtWidgets.QMessageBox.critical(self, "Polling error", str(exc))

    # -------------------------
    # Low-level send helper (widget-level)
    # -------------------------
    def send_cmd(self, cmd: str, read: bool = True, binary: bool = False, timeout_s: Optional[float] = None):
        if self.inst is None:
            raise RuntimeError("Instrument not connected")
        # Prefer driver methods, fallback to adapter.resource
        try:
            if not binary:
                if read:
                    return self.inst.ask(cmd)
                else:
                    self.inst.write(cmd)
                    return None
            else:
                # attempt binary read via adapter.resource if available
                try:
                    self.inst.write(cmd)
                except Exception:
                    pass
                adapter = getattr(self.inst, "adapter", None)
                resource = getattr(adapter, "resource", None) if adapter is not None else None
                old_t = None
                if resource is not None:
                    try:
                        if timeout_s is not None and hasattr(resource, "timeout"):
                            old_t = resource.timeout
                            resource.timeout = int(timeout_s * 1000)
                    except Exception:
                        old_t = None
                    try:
                        if hasattr(resource, "read_bytes"):
                            try:
                                return resource.read_bytes(2**20)
                            except Exception:
                                b = b""
                                try:
                                    while True:
                                        chunk = resource.read_bytes(4096)
                                        if not chunk:
                                            break
                                        b += chunk
                                except Exception:
                                    pass
                                return b
                        elif hasattr(resource, "read_raw"):
                            try:
                                return resource.read_raw()
                            except Exception:
                                return resource.read()
                        else:
                            return resource.read()
                    finally:
                        try:
                            if old_t is not None:
                                resource.timeout = old_t
                        except Exception:
                            pass
                # fallback to driver read methods
                try:
                    if hasattr(self.inst, "read_bytes"):
                        return self.inst.read_bytes(2**20)
                    if hasattr(self.inst, "read_raw"):
                        return self.inst.read_raw()
                except Exception:
                    pass
                # final fallback: try ask and encode
                try:
                    text = self.inst.ask(cmd)
                    if text is None:
                        return b""
                    if isinstance(text, bytes):
                        return text
                    return str(text).encode("utf-8")
                except Exception as e:
                    raise RuntimeError(f"Binary read failed: {e}")
        except Exception:
            raise

    def _send_raw_with_feedback(self, cmd: str):
        if not self.inst:
            QtWidgets.QMessageBox.warning(self, "No Instrument", "Connect first.")
            return
        try:
            resp = None
            try:
                resp = self.inst.ask(cmd)
            except Exception:
                try:
                    self.inst.write(cmd)
                except Exception:
                    resp = "OK (no reply)"
            self._log_raw(cmd, resp)
        except Exception as e:
            self._log_raw(cmd, f"ERROR: {traceback.format_exc()}")
            QtWidgets.QMessageBox.warning(self, "Command Error", str(e))

    def _log_raw(self, cmd: str, resp: Any):
        self.cmd_resp_te.appendPlainText(f"> {cmd}< {resp}")

    # -------------------------
    # Raw command panel
    # -------------------------
    def send_raw_command(self):
        cmd = self.cmd_le.text().strip()
        if not cmd or not self.inst:
            return
        try:
            if cmd.startswith(">"):
                self.inst.write(cmd[1:].strip())
                self.cmd_resp_te.appendPlainText(f"WROTE: {cmd[1:].strip()}")
            else:
                resp = self.inst.ask(cmd)
                self.cmd_resp_te.appendPlainText(f"> {cmd}< {resp}")
        except Exception as e:
            self.cmd_resp_te.appendPlainText(f"ERROR sending {cmd}: {e}")

    # -------------------------
    # Control handlers (wired)
    # -------------------------
    def on_sensitivity_changed(self, idx):
        if not self.inst:
            return
        try:
            val = float(self.sensitivity_cb.itemText(idx))
            try:
                self.inst.sensitivity = val
            except Exception:
                self.send_cmd(f"SEN {val}", read=False)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Sensitivity Error", str(e))

    def on_tc_changed(self, idx):
        if not self.inst:
            return
        try:
            val = float(self.tc_cb.itemText(idx))
            try:
                self.inst.time_constant = val
            except Exception:
                self.send_cmd(f"TC {val}", read=False)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "TC Error", str(e))

    def on_slope_changed(self, idx):
        if not self.inst:
            return
        try:
            val = int(self.slope_cb.currentText())
            try:
                self.inst.slope = val
            except Exception:
                self.send_cmd(f"SLOPE {val}", read=False)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Slope Error", str(e))

    def on_imode_changed(self, idx):
        if not self.inst:
            return
        try:
            self.send_cmd(f"IMODE {idx}", read=False)
            if idx == 0:
                try:
                    self.inst.set_voltage_mode()
                except Exception:
                    pass
            elif idx == 1:
                try:
                    self.inst.set_current_mode(low_noise=False)
                except Exception:
                    pass
            elif idx == 2:
                try:
                    self.inst.set_current_mode(low_noise=True)
                except Exception:
                    pass
            self._populate_after_connect()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "IMODE Error", str(e))

    def on_vmode_changed(self, idx):
        if not self.inst:
            return
        try:
            # map UI idx 0,1,2 -> VMODE 1,2,3
            self.send_cmd(f"VMODE {idx+1}", read=False)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "VMODE Error", str(e))

    def on_float_toggled(self, state):
        if not self.inst:
            return
        try:
            n = 1 if state else 0
            self.send_cmd(f"FLOAT {n}", read=False)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "FLOAT Error", str(e))

    def on_lf_changed(self, _):
        if not self.inst:
            return
        try:
            n1 = self.lf_mode_cb.currentIndex()
            n2 = self.lf_freq_cb.currentIndex()
            self.send_cmd(f"LF {n1} {n2}", read=False)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "LF Error", str(e))

    def on_auto_acgain_toggled(self, state):
        if not self.inst:
            return
        try:
            self.send_cmd(f"AUTOMATIC {1 if state else 0}", read=False)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "AUTOMATIC Error", str(e))

    def on_refsrc_changed(self, idx):
        if not self.inst:
            return
        try:
            self.send_cmd(f"IE {idx}", read=False)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "REFSRC Error", str(e))

    def on_refn_changed(self, v):
        if not self.inst:
            return
        try:
            try:
                self.inst.harmonic = int(v)
            except Exception:
                self.send_cmd(f"HARM {int(v)}", read=False)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "REFN Error", str(e))

    def on_refp_changed(self, v):
        if not self.inst:
            return
        try:
            try:
                self.inst.phase = float(v)
            except Exception:
                self.send_cmd(f"PHASE {float(v)}", read=False)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "REFP Error", str(e))

    def on_osc_amp_changed(self, v):
        if not self.inst:
            return
        try:
            self.send_cmd(f"OA. {float(v)}", read=False)
            try:
                cur = float(self.inst.ask("OA.?"))
                self.osc_amp_sb.blockSignals(True)
                self.osc_amp_sb.setValue(cur)
                self.osc_amp_sb.blockSignals(False)
            except Exception:
                pass
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Osc Amp Error", str(e))

    def on_osc_freq_changed(self, v):
        if not self.inst:
            return
        try:
            self.send_cmd(f"OF. {float(v)}", read=False)
            try:
                cur = float(self.inst.ask("OF.?"))
                self.osc_freq_sb.blockSignals(True)
                self.osc_freq_sb.setValue(cur)
                self.osc_freq_sb.blockSignals(False)
            except Exception:
                pass
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Osc Freq Error", str(e))

    def _on_dac_set(self, idx, val):
        if not self.inst:
            return
        try:
            self.send_cmd(f"DAC. {idx} {float(val)}", read=False)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, f"DAC{idx} Error", str(e))

    # -------------------------
    # Extras: Auto commands with ST resync helper
    # -------------------------
    def _auto_with_resync(self, cmd: str, label: str):
        if not self.inst:
            QtWidgets.QMessageBox.warning(self, label, "Connect first.")
            return
        try:
            resp = self.inst.ask(cmd)
            self._log_raw(cmd, resp)
            # wait for bit0 of ST to clear (command complete)
            for _ in range(200):
                try:
                    st = self.inst.ask("ST")
                    try:
                        st_int = int(str(st).strip())
                    except Exception:
                        try:
                            st_int = int(str(st).strip(), 16)
                        except Exception:
                            st_int = None
                    if st_int is not None and not (st_int & 0x1):
                        break
                except Exception:
                    pass
                time.sleep(0.05)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, label + " Error", str(e))
    def on_query_fast_data(self):
        if not self.inst:
            QtWidgets.QMessageBox.warning(self, "No Instrument", "Connect first.")
            return
        try:
            delim = self.get_delimiter()
            resp = self.inst.ask("?")
            if resp is None:
                self.cmd_resp_te.appendPlainText("?: <no response>")
                return
            # split by delimiter
            tokens = str(resp).strip().split(delim)
            self.cmd_resp_te.appendPlainText(f"? -> {tokens}")
        except Exception as e:
            self.cmd_resp_te.appendPlainText(f"?: ERROR {e}")

    # -------------------------
    # Noise toggle
    # -------------------------
    def on_toggle_noise(self):
        if not self.inst:
            QtWidgets.QMessageBox.warning(self, "No Instrument", "Connect first.")
            return
        try:
            resp = self.inst.ask("NOISE?")
            cur = None
            s = str(resp).strip()
            if s in ("1", "ON", "on", "+1"):
                cur = 1
            elif s in ("0", "OFF", "off", "-1"):
                cur = 0
            if cur is None:
                self._send_raw_with_feedback("NOISE")
            else:
                new = 0 if cur else 1
                self._send_raw_with_feedback(f"NOISE {new}")
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "NOISE Error", str(e))

    # -------------------------
    # Offsets / Auto Offsets
    # -------------------------
    def on_offsets(self):
        if not self.inst:
            return
        try:
            resp = self.inst.ask("AXO")
            self._log_raw("AXO", resp)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "AXO Error", str(e))

    # -------------------------
    # Save / Recall
    # -------------------------
    def on_save_slot(self):
        if not self.inst:
            return
        n = int(self.save_spin.value())
        try:
            resp = self.inst.ask(f"SAV {n}")
            self._log_raw(f"SAV {n}", resp)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "SAV Error", str(e))

    def on_recall_slot(self):
        if not self.inst:
            return
        n = int(self.save_spin.value())
        try:
            resp = self.inst.ask(f"RCL {n}")
            self._log_raw(f"RCL {n}", resp)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "RCL Error", str(e))

    # -------------------------
    # ERR? query
    # -------------------------
    def on_err_query(self):
        if not self.inst:
            return
        try:
            resp = self.inst.ask("ERR?")
            self.err_lbl.setText(f"Last ERR?: {resp}")
            self._log_raw("ERR?", resp)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "ERR? Error", str(e))

    # -------------------------
    # Curve buffer: set LEN, start CBD, download DC., export CSV
    # -------------------------
    def on_set_len(self):
        if not self.inst:
            return
        L = int(self.len_spin.value())
        try:
            resp = self.inst.ask(f"LEN {L}")
            self._log_raw(f"LEN {L}", resp)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "LEN Error", str(e))

    def on_cbd_start(self):
        if not self.inst:
            return
        try:
            resp = self.inst.ask("CBD")
            self._log_raw("CBD", resp)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "CBD Error", str(e))
    def read_dcb_curve(self, curve_idx: int, length: Optional[int] = None, timeout_s_per_kb: float = 2.0):
        if self.inst is None:
            raise RuntimeError("Instrument not connected")
        if length is None:
            try:
                length = int(self.inst.ask("LEN"))
            except Exception:
                length = int(self.len_spin.value())
        expected_bytes = 2 * int(length)
        # set adequate timeout proportional to data size (seconds)
        timeout_s = max(5.0, (expected_bytes / 1024.0) * timeout_s_per_kb)
        # issue DCB command (write preferred for binary path)
        try:
            try:
                self.inst.write(f"DCB {curve_idx}")
            except Exception:
                # some drivers expect ask; still safe to write first
                _ = self.inst.ask(f"DCB {curve_idx}")
            raw = self._read_exact_bytes(expected_bytes, timeout_s)
        except Exception as e:
            # fallback: try ASCII DC. when binary fails
            ascii_vals = self._read_dc_dot_ascii(curve_idx, length)
            return ascii_vals
        # unpack big-endian signed 16-bit MSB-first
        try:
            cnt = len(raw) // 2
            vals = list(struct.unpack(">" + f"{cnt}h", raw[:cnt*2]))
            # If curve is frequency low/high pair assembly handled by caller
            return vals
        except Exception:
            # try little-endian fallback
            try:
                cnt = len(raw) // 2
                vals = list(struct.unpack("<" + f"{cnt}h", raw[:cnt*2]))
                return vals
            except Exception as e2:
                raise RuntimeError("Failed to unpack DCB binary data") from e2
    def _read_dc_dot_ascii(self, curve_idx: int, length: Optional[int] = None):
        # get delimiter and terminator
        delim = self.get_delimiter()
        term = self.get_usb_terminator().decode('latin1', errors='ignore')
        try:
            resp = self.inst.ask(f"DC. {curve_idx}")
            if resp is None:
                return []
            s = str(resp)
            # split by terminator first, then by delimiter
            s = s.rstrip(term)
            tokens = s.split(delim)
            vals = []
            for t in tokens:
                t = t.strip()
                if not t:
                    continue
                try:
                    vals.append(float(t))
                except Exception:
                    # ignore unparsable tokens
                    pass
            return vals
        except Exception:
            return []

    def read_dct_multi(self, mask: int):
        # DCT transfers multiple curves; mask bits define order per table
        delim = self.get_delimiter()
        all_text = ""
        # DCT is a streaming multi-line response until finished â€” use ask loop until terminator or empty
        try:
            resp = self.inst.ask(f"DCT {mask}")
            if resp is None:
                return []
            all_text = str(resp)
            # split by newlines then tokens
            lines = all_text.splitlines()
            parsed = []
            for line in lines:
                tokens = line.split(delim)
                parsed.append([float(t.strip()) for t in tokens if t.strip()])
            return parsed
        except Exception:
            return []

    # helper to read curve 15/16 and assemble 32-bit mHz
    def read_frequency_curve(self, low_idx: int = 15, high_idx: int = 16, length: Optional[int] = None):
        low = self.read_dcb_curve(low_idx, length)
        high = self.read_dcb_curve(high_idx, length)
        if not low or not high:
            return []
        assembled = []
        # per manual: value16 signed 16-bit (upper), value15 unsigned 16-bit (lower)
        for l, h in zip(low, high):
            # ensure unsigned for low
            lower = l & 0xFFFF
            upper = h & 0xFFFF
            freq_mHz = (upper << 16) + lower
            assembled.append(freq_mHz)
        return assembled

    def _on_download_curve_clicked(self):
        try:
            vals = self.download_curve_binary()
            if isinstance(vals, (bytes, bytearray)):
                QtWidgets.QMessageBox.information(self, "Download", f"Raw bytes downloaded: {len(vals)} bytes")
                return
            self.curve_table.setRowCount(0)
            for i, v in enumerate(vals):
                r = self.curve_table.rowCount()
                self.curve_table.insertRow(r)
                self.curve_table.setItem(r, 0, QtWidgets.QTableWidgetItem(str(i)))
                self.curve_table.setItem(r, 1, QtWidgets.QTableWidgetItem(str(v)))
            QtWidgets.QMessageBox.information(self, "Download", f"Downloaded {len(vals)} points")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Download Error", str(e))

    def on_download_buffer(self):
        if not self.inst:
            return
        try:
            ch_text = self.curve_chan_cb.currentText()
            ch = DC_CHANNELS.get(ch_text, 0)
            L = int(self.len_spin.value())
            # start background download worker
            worker = DownloadWorker(self.inst, ch, L, timeout_s=10.0)
            t = QtCore.QThread()
            worker.moveToThread(t)

            def on_finished(vals):
                self.curve_data = vals
                self._populate_curve_table(vals)
                self._log_raw(f"DC. {ch}", f"{len(vals)} points")
                t.quit()
                worker.deleteLater()

            def on_raw_bytes(b):
                QtWidgets.QMessageBox.information(self, "Download", f"Raw bytes downloaded: {len(b)} bytes")
                t.quit()
                worker.deleteLater()

            def on_error(e):
                QtWidgets.QMessageBox.warning(self, "Download Error", str(e))
                t.quit()
                worker.deleteLater()

            worker.finished.connect(on_finished)
            worker.raw_bytes.connect(on_raw_bytes)
            worker.error.connect(on_error)
            t.started.connect(worker.run)
            t.start()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Download Error", str(e))

    def _populate_curve_table(self, vals: List[float]):
        self.curve_table.setRowCount(len(vals))
        for i, v in enumerate(vals):
            idx_item = QtWidgets.QTableWidgetItem(str(i))
            val_item = QtWidgets.QTableWidgetItem(f"{v:.6g}")
            self.curve_table.setItem(i, 0, idx_item)
            self.curve_table.setItem(i, 1, val_item)

    def download_curve_binary(self):
        # synchronous convenience wrapper - uses DownloadWorker logic in-process
        ch_text = self.curve_chan_cb.currentText()
        ch = DC_CHANNELS.get(ch_text, 0)
        length = int(self.len_spin.value())
        # try binary first
        try:
            # ask and possibly get bytes
            out = self.send_cmd(f"DCB {ch}", read=True, binary=True, timeout_s=10.0)
            if out and len(out) >= 2:
                # attempt unpack
                for fmt_prefix in (">", "<"):
                    try:
                        count = len(out) // 2
                        vals = list(struct.unpack(fmt_prefix + f"{count}h", out[:count * 2]))
                        return vals
                    except Exception:
                        continue
            # fallback to ASCII
            resp = self.send_cmd(f"DC. {ch}", read=True, binary=False, timeout_s=10.0)
            if resp is None:
                return []
            if isinstance(resp, (list, tuple)):
                return [float(v) for v in resp]
            s = str(resp).strip()
            if "," in s:
                parts = [p for p in s.split(",") if p.strip()]
            else:
                parts = [p for p in s.split() if p.strip()]
            vals = []
            for p in parts:
                try:
                    vals.append(float(p))
                except Exception:
                    pass
            if vals:
                return vals
            # segmented ASCII reads
            for i in range(length):
                try:
                    r = self.inst.ask(f"DC. {ch} {i}")
                    vals.append(float(str(r).strip()))
                except Exception:
                    break
            return vals
        except Exception:
            # last-resort empty list
            return []

    def on_export_curve_csv(self):
        if not self.curve_data:
            QtWidgets.QMessageBox.information(self, "No Data", "No curve data to export.")
            return
        fname, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Save Curve CSV", "curve.csv", "CSV Files (*.csv);;All Files (*.*)")
        if not fname:
            return
        try:
            with open(fname, "w", newline='') as f:
                w = csv.writer(f)
                w.writerow(["Index", "Value"])
                for i, v in enumerate(self.curve_data):
                    w.writerow([i, v])
            QtWidgets.QMessageBox.information(self, "Saved", f"Saved {len(self.curve_data)} points to {fname}")
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Save Error", str(e))

    # -------------------------
    # Auto phase / auto sensitivity / auto measure hooks
    # -------------------------
    def on_auto_phase(self):
        self._auto_with_resync("AQN", "Auto-Phase")

    def on_auto_sensitivity(self):
        self._auto_with_resync("AS", "Auto-Sensitivity")

    def on_auto_measure(self):
        chan = 1 if self.asm_chan_cb.currentIndex() == 0 else 2
        self._auto_with_resync(f"ASM {chan}", "Auto-Measure")

    def closeEvent(self, event):
        try:
            self.stop_polling()
            if self.inst:
                try:
                    self.inst.shutdown()
                except Exception:
                    pass
        except Exception:
            pass
        super().closeEvent(event)


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    w = Ametek7230ControlWidget()
    w.resize(1200, 800)
    w.show()
    sys.exit(app.exec_())
